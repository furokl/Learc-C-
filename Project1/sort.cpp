#include "sort.h"
#include <algorithm>

/*
* @.'Сортировка методом выбора'
*	1. Начиная с элемента под индексом [0], ищем в массиве наименьшее значение.
*	2. Найденное значение меняем местами с нулевым элементом.
*	3. Повторяем шаги №1 и №2 уже для следующего индекса в массиве.
* 
* Есть в библиотеке <algorithm> - std::sort
* Пример
*	std::sort(array, array+length);
*/
void sort_choice(int* array, int array_length) {
	for (int i = 0; i < array_length - 1; ++i)
	{
		int temp = i;
		for (int j = i + 1; j < array_length; ++j)
		{
			if (array[j] < array[temp])
				temp = j;
		}
		std::swap(array[i], array[temp]);
	}
}

/*
* @.'Пузырьковая сортировка' (неоптимизированная версия)
*	1. Сравнивается элемент массива под индексом [0] с элементом массива под индексом [1].
*		Если элемент под индексом [0] больше элемента под индексом [1], то значения меняются местами.
*	2. Затем мы перемещаемся к следующей паре значений: элемент под индексом [1] и элемент под индексом [2]
*		и так до тех пор, пока не достигнем конца массива.
*	3. Повторяем шаг №1 и №2 до тех пор, пока весь массив не будет отсортирован.
*/
void sort_bubble_no(int* array, int array_length) {
	for (int i = 0; i < array_length - 1; ++i)
	{
		for (int j = i; j < array_length - 1; ++j)
		{
			if (array[j + 1] < array[j])
				std::swap(array[j + 1], array[j]);

		}
	}
}

/*
* @.'Пузырьковая сортировка' (оптимизированная, а работает дольше)
*	1. Сравнивается элемент массива под индексом [0] с элементом массива под индексом [1].
*		Если элемент под индексом [0] больше элемента под индексом [1], то значения меняются местами.
*	2. Затем мы перемещаемся к следующей паре значений: элемент под индексом [1] и элемент под индексом [2]
*		и так до тех пор, пока не достигнем конца массива.
*	3. Повторяем шаг №1 и №2 до тех пор, пока весь массив не будет отсортирован.
*	4. С каждой новой итерацией не нужно перепроверять элементы, которые уже были отсортированы.
*	5. Если на протяжении всей итерации не выполнится ни одной замены, то мы знаем, что массив уже отсортирован.
*/
void sort_bubble(int* array, int array_lenght) {
	for (int i = 0; i < array_lenght - 1; ++i)
	{
		bool swapped(false);
		for (int j = 0; j < array_lenght - i - 1; ++j)
		{
			if (array[j + 1] < array[j]) {
				swapped = true;
				std::swap(array[j + 1], array[j]);
			}
		}
		if (!swapped) break;
	}
}

/*
* @.'Бинарный поиск' (только в отсортированном массиве)
*	Смотрим на центральный элемент массива.
*	Если центральный элемент массива больше элемента, который мы ищем, то всё, что
*		находится справа от центрального элемента - отбрасываем.
*	Если центральный элемент меньше элемента, который мы ищем, то 
*		отбрасываем всё, что находится слева от центрального элемента.
*	Если центральный элемент равен элементу, который мы ищем, то возвращаем индекс этого элемента.
*	Если перебрали весь массив и не нашли искомого значения, то возвращаем контрольное значение с
*		выводом not found
*/

int binarySearch(int *array, int target, int min, int max) {
	while (1) {
		int midpoint = (max + min) / 2;
		if (array[midpoint] == target) return midpoint;
		else if (min == max) return -1;

		(array[midpoint] < target) ?
			min = midpoint + 1 :
			max = midpoint - 1;
	}
}

int binarySearch_recursive(int *array, int target, int min, int max) {
	int midpoint = (max + min) / 2;

	if (array[midpoint] == target) return midpoint;
	else if (min == max) return -1;
	
	(array[midpoint] < target) ?
		binarySearch_recursive(array, target, midpoint + 1, max) :
		binarySearch_recursive(array, target, min, midpoint - 1);
}