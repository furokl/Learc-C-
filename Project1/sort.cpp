#include "sort.h"
#include <algorithm>

/*
* @.'Сортировка методом выбора'
*	1. Начиная с элемента под индексом [0], ищем в массиве наименьшее значение.
*	2. Найденное значение меняем местами с нулевым элементом.
*	3. Повторяем шаги №1 и №2 уже для следующего индекса в массиве.
* 
* Есть в библиотеке <algorithm> - std::sort
* Пример
*	std::sort(array, array+length);
*/
void sort_choice(int* array, int array_length) {
	for (int i = 0; i < array_length - 1; ++i)
	{
		int temp = i;
		for (int j = i + 1; j < array_length; ++j)
		{
			if (array[j] < array[temp])
				temp = j;
		}
		std::swap(array[i], array[temp]);
	}
}

/*
* @.'Пузырьковая сортировка' (неоптимизированная версия)
*	1. Сравнивается элемент массива под индексом [0] с элементом массива под индексом [1].
*		Если элемент под индексом [0] больше элемента под индексом [1], то значения меняются местами.
*	2. Затем мы перемещаемся к следующей паре значений: элемент под индексом [1] и элемент под индексом [2]
*		и так до тех пор, пока не достигнем конца массива.
*	3. Повторяем шаг №1 и №2 до тех пор, пока весь массив не будет отсортирован.
*/
void sort_bubble_no(int* array, int array_length) {
	for (int i = 0; i < array_length - 1; ++i)
	{
		for (int j = i; j < array_length - 1; ++j)
		{
			if (array[j + 1] < array[j])
				std::swap(array[j + 1], array[j]);

		}
	}
}

/*
* @.'Пузырьковая сортировка' (оптимизированная)
*	1. Сравнивается элемент массива под индексом [0] с элементом массива под индексом [1].
*		Если элемент под индексом [0] больше элемента под индексом [1], то значения меняются местами.
*	2. Затем мы перемещаемся к следующей паре значений: элемент под индексом [1] и элемент под индексом [2]
*		и так до тех пор, пока не достигнем конца массива.
*	3. Повторяем шаг №1 и №2 до тех пор, пока весь массив не будет отсортирован.
*	4. С каждой новой итерацией не нужно перепроверять элементы, которые уже были отсортированы.
*	5. Если на протяжении всей итерации не выполнится ни одной замены, то мы знаем, что массив уже отсортирован.
*/
void sort_bubble(int* array, int array_lenght) {
	for (int i = 0; i < array_lenght - 1; ++i)
	{
		bool swapped(false);
		for (int j = 0; j < array_lenght - i - 1; ++j)
		{
			if (array[j + 1] < array[j]) {
				swapped = true;
				std::swap(array[j + 1], array[j]);
			}
		}
		if (!swapped) break;
	}
}