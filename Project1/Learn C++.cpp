#include <iostream>

/*
* Created by Logunov on 22/12/2022
* @comment: Прохождение и конспектирование курса "Ravesli"
* Спец. символы
*	Теория		-	@.'
*	Советы		-	#.'
*	Правила		-	!.'
*/

#ifdef Введение в программирование

* @.'Программа' -это 'набор инструкций', которые указывают компьютеру, что ему нужно делать.
*
* @.'Железо' - физическая часть, выполняющая эти инструкции.
*
* @.'Машинный код' - ограниченный набор инструкций, которое изначально понимает процессор.
*	1. Каждая команда состоит из определенной последовательности 0 и 1 (биты / двоичный код)
*	2. Каждый набор бит переводится процессором в инструкции для выполнения определенного задания (например, сравнить два числа)
*	Пример: 10110000 01100001
*
* @.'Язык Ассемблера' - первый ЯП, в котором каждая команда идентифицируется коротким именем.
*	1. Преимущество: производительность
*	2. Недостаток: программирование адаптируется к конкретному процессору.
*	Пример: mov al, 061h
*
* @.'Высокоуровневые ЯП' - позволяют писать и выполнять программы, не переживая о совместимости кода с разными архитектурами процессоров.
*	Программы, написанные на них также должны быть переведены в машинный код перед выполнением.
*	Есть два варианта это сделать:
*		1. Компиляция
*		2. Интерпретация
*
* @.'Компилятор' - программа, которая читает код и 'создает' автономную 'исполняемую программу', которую процессор понимает напрямую.
*	1. Преимущество: при повторном запуске программы компиляция не выполняется.
*	Пример: 
*		'Код ЯП				->	Компилятор		->	Исполняемый файл'
*		'Исполняемый файл	->	Процессор		->	Результат программы'
*		(C, C++, Pascal)
*
* @.'Интерпретатор' - программа, которая 'напрямую выполняет код', без его предыдущей компляции в исполняемый файл.
*	1. Преимущество: гибкость
*	2. Недостаток: процесс интерпретации выполняется повторно при каждом запуске программы
*	Пример: 
*		'Код ЯП				->	Интерпретатор	->	Процессор	->	Результат программы'
*		(Perl, JavaScript)
*	(*Java может как компилироваться, так и интерпретироваться)

#endif // Введение в программирование

#ifdef Введение в ЯП С и С++

* @.'Язык С "Си"'
* Разработан в 1972 г. Деннисом Ритчи, как язык для ОС.
*	Цель: минималистичный язык, который предоставлял бы эффективный доступ к памяти, с относительно быстрым выполнением
*	Стандарты:
*		ANSI 	C89
*		ISO		C90
*		ANSI	C99
*
* @.'Язык С++'
* Разработан в 1979 г. Бьёрном Страуструпом в качестве дополнения к Си.
*	Особенность: введение ООП
*	Стандарты:
*		ISO 1998
*		C++03
*		C++11 (* каждые 3 года)
*		C++14
*		C++17
*		C++20
*
* @.'Философия'
* Можно определить выражением "Доверять программисту"
*	Компилятор не будет мешать сделать что-то новое, что имеет смысл,
*		но также не будет мешать сделать что-то такое, что может привести к сбою программы.

#endif // Введение в языки программирования С и С++

#ifdef Введение в разработку ПО

* @.'Схема разработки ПО'
*
*	1.'Определите проблему'
*		Это шаг "Что?"
*		Необходимо понять, что вы хотите, чтобы ваша программа делала
*
*	2.'Разработайте решение'
*		Вопрос "Как?"
*		Каким образом можно решить проблему;
*			довольно часто пренебрегают, способов решения задачи может быть много,
*			только часть из них - хорошие, а часть - плохие
*		Как правило, хорошие решения обладают следующими характеристиками
*			'Простота'
*			'Хорошая документация'
*			'Модульный принцип' (может быть повторна использована, изменена позже)
*			'Надежность' (проверка на ошибки)
*
*	3.'Напишите программу, используя решение'
*
*	4.'Скомпилируйте программу'
*		@.'Работа компилятора' состоит из двух частей:
*			Проверка программы на соответствие правилам языка С++ (проверка синтаксиса)
*			Конвертация каждого исходного файла (*.cpp) с кодом в объектный файл на машинном языке
*
*	5.'Соедините объектные файлы (Линкинг)'
*		@.'Линкинг' - процесс связывания всех объектных файлов, генерируемых компилятором, в единую исполняемую программу.
*		Это делается при помощи программы Линкер / Компоновщик
*		'Исполняемый файл	->	Компиляция	->	Объектный файл	->	 Линкер	->	Исполняемый файл'
*
*	6.'Протестируйте и отладьте программу'
*		При помощи встроенного отладчика; также IDE имеет ряд возможностей:
*			Комплексная помощь
*			Дополнение кода
*			Система контроля версий

#endif // Введение в разработку ПО

#ifdef Режимы конфигурации Debug и Release

* @.'Конфигурация сборки' - это 'набор настроек' проекта, которые определяют принцип его построения.
*	Состоит из:
*		Имени исполняемого файла
*		Имени директории исполняемого файла
*		Имен директорий, в которых IDE будет искать другой код и файлы библиотек
*		Информации об отладке и параметрах оптимизации вашего проекта
* 
* @.'Debug' - предназначен для отладки программы.
*	Отключает все настройки по оптимизации
*	Включает информацию об отладке
* 
* @.'Release' - используется во время сборки программы для её дальнейшего выпуска
*	Оптимизируется по размеру и производительности
*	Не содержит дополнительную информацию об отладке

#endif // Режимы конфигурации Debug и Release

#ifdef Конфигурация компилятора

* Настроим проект Visual Studio для обучения
* Обозреватель решений	
*	->	Свойства (* установить 'Все конфигурации')
*		->	C/C++	
*			->	Общие	
*				->	'Уровень предупреждения 4'
*			->	Язык	
*				->	'Стандарт языка С++ (С++20?)'
*				->	'Отключить расширения языка Да'

#endif // Конфигурация компилятора

#ifdef Структура программ

* @.'Стейтмент' - распространенный тип инструкций, 'наименьшая независимая единица' в языке С++.
* Пример
*	// Стейтмент объявления
*	int x;
*	// Стейтмент присваивания
*	x = 5;
*	// Стейтмент вывода
*	std::cout << x;
* 
* @.'Выражение' - это математический объект, который создается для проведения вычисления и нахождения результата.
* Пример
*	2 + 3
*	2 + x
*	x + y
*	(2 + x) * (y - 3)
* 
* @.'Функция' - это последовательность стейтментов для выполнения определенного задания.
*	Каждая программа в С++ должна содержать главную функцию main(),
*		именно с первого стейтмента, находящегося в функции main() начинается выполнение всей программы.
* Пример
*	Функция max() может содержать стейтменты, для определения наибольшего из заданных чисел.
* 
* #.'Совет'
*	Размещайте функцию main() в файле .cpp с именем, совпадающим с именем проекта
* 
* @.'Библиотека' - это 'набор скомпилированного кода', который был 'упакован' 
*		для повторного использования в других программах
* Пример
*	#include <iostream>
* 
* @.'Пример простой программы'
*	1.	#include <iostream>
*	2.	
*	3.	int main()
*	4.	{
*	5.		std::cout << "Hello, world!";
*	6.		return 0;
*	7.	}
*	
*	Строка №1: 
*		@.'Директива препроцессора' - сообщает компилятору, что ему нужно выполнить определенное задание,
*			в данном случае подключить содержимое файла <iostream>
*
*	Строка №2:
*		Пустое пространство, игнорируется компилятором
*
*	Строка №3:
*		Объявление главной функции main()
*
*	Строка №4 и №7:
*		Указываем компилятору область видимости функции main()
*
*	Строка №5:
*		Стейтмент вывода.
*			std::cout - это специальный объект, используя который мы можем выводить данные на экран
*			<< - это оператор вывода
*			Всё, что отправляется в std::cout - выводится на экран ("Hello, world!")
*
*	Строка №6:
*		Оператор возврата 'return'
*		@.'Код состояния' - когда программа завершает свое выполнение, функция main() передает обратно в ОС
*			значение, которое указывает на результат выполнения программы
*				0 - всё хорошо
*				иначе - что-то пошло не так

#endif // Структура программ

#ifdef Комментарии

* @.'Комментарий' - Это строка/строки текста, вставленные в исходный код,
*		для объяснения того, что этот код делает.
* 
* 'Однострочный комментарий'	-	//
*	Лучше размещать над строками кода
*	Пример
*		// cout и endl находятся в библиотеке iostream
*		std::cout << «Hello, world!» << std::endl;
* 
* 'Многострочный комментарий'	-	/* */
*	Пример
*		/*
*		* Звёздочки слева
*		* упрощают чтение текста
*		*/
*
*		/* Это многострочный комментарий /* */ а это уже не комментарий */
*
* !.'Правило' - Не используйте вложенные комментарии!
* 
* @.'Как правильно писать комментарии?'
*	1. На уровне библиотек/программ/функций комментарии отвечают на вопрос
*		'Что?'
*	Пример
*		// Эта функция использует метод Ньютона для вычисления корня функции
* 
*	2. Внутри библиотек/программ/функций комментарии отвечают на вопрос
*		'Как?'
*	Пример
*		// Чтобы получить рандомный (случайный) элемент, мы выполняем следующее:
* 
*		// 1) Составляем список всех элементов.
*		// 2) Вычисляем среднее значение для каждого элемента, исходя из его веса, цвета и цены.
*		// 3) Выбираем любое число.
*		// 4) Определяем соответствие элемента случайно выбранному числу.
*		// 5) Возвращаем случайный элемент.
* 
*	3. На уровне стейтментов комментарии отвечают на вопрос
*		'Почему?'
*	Пример
*		// Мы решили использовать список вместо массива,
*		// потому что массивы осуществляют медленную вставку.
* 
* @.'Закомментировать код' - корвертировать одну или несколько строк кода в комментарии.
*	Таким образом, исключаем часть кода из компиляции.
*	В Visual Studio 'быстрые клавиши'
*		Закомментировать	-	'Ctrl + K' потом 'Ctrl + C'
*		Раскомментировать	-	'Ctrl + K' потом 'Ctrl + U'
*
* Причины закомментировать код:
*	1. Вы работаете над новой частью кода, которая пока что не рабочая.
*	2. Вы написали код, который компилируется, но работает не так, как нужно
*		и сейчас у вас нет времени с этим возиться.
*	3. Поиск корня ошибки, поочередно отключая части вашего кода.

#endif // Комментарии

#ifdef Объект

* @.'Объект' - это 'часть памяти', которая может хранить значение.
* При создании объекта, часть оперативной памяти выделяется для этого объекта.
* Аналогия
*	Почтовый ящик, куда мы помещаем информацию и откуда ее извлекаем
* 
* @.'Переменная' - Объект с именем.
* Стейтмент a = 8;
*	где 'а' - это переменная.
* 
* Все переменные являются l-values & r-values 
* 'l-values' - значение, которое 'имеет' свой собственный 'адрес' в памяти 
* 'r-values' - значение, 'не имеющего' постоянного 'адреса' в памяти
* (подробнее в следующих уроках)
* 
* Часто путают Инициализацию и Присваивание (?)
* 'Присваивание'
*	int a;
*	a = 8;
* 'Инициализация'
*	int a = 8
* 
* !.'Правило' - Если у вас изначально 'имеется значение' для переменной, то
*	'используйте инициализацию', вместо присваивания
* 
* При объявлении переменной, ей дается ячейка в памяти, при этом в ней будет хранится мусор
*	int a;
*	std::cout << a; // ошибка компиляции (в старых версиях выведет мусор по типу 2362346)

#endif // Объект

#ifdef Параметры и аргументы функций

* @.'Параметр функции - это 'переменная, которая используется в функции' и значение
*	которой предоставляет caller (вызывающий объект).
* Пример
*	void printValue(int a) // один параметр типа int
*	{
*		std::cout << a << std::endl;
*	}
* 
* @.'Аргумент функции - это значение, которое передается из caller-a в функцию и
*	которое указывается в скобках при вызове функции в caller-e
* Пример
*	printValue(7); // 7 - аргумент функции printValue()

#endif // Параметры и аргументы функций


int main() {

	return EXIT_SUCCESS;
}