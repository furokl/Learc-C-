/*
* Created by Logunov on 22/12/2022
* @comment: Прохождение и конспектирование курса "Ravesli"
* Спец. символы
*	Теория		-	@.'
*	Советы		-	#.'
*	Правила		-	!.'
*/

#ifdef Введение в программирование

* @.'Программа' -это 'набор инструкций', которые указывают компьютеру, что ему нужно делать.
*
* @.'Железо' - физическая часть, выполняющая эти инструкции.
*
* @.'Машинный код' - ограниченный набор инструкций, которое изначально понимает процессор.
*	1. Каждая команда состоит из определенной последовательности 0 и 1 (биты / двоичный код)
*	2. Каждый набор бит переводится процессором в инструкции для выполнения определенного задания (например, сравнить два числа)
*	Пример: 10110000 01100001
*
* @.'Язык Ассемблера' - первый ЯП, в котором каждая команда идентифицируется коротким именем.
*	1. Преимущество: производительность
*	2. Недостаток: программирование адаптируется к конкретному процессору.
*	Пример: mov al, 061h
*
* @.'Высокоуровневые ЯП' - позволяют писать и выполнять программы, не переживая о совместимости кода с разными архитектурами процессоров.
*	Программы, написанные на них также должны быть переведены в машинный код перед выполнением.
*	Есть два варианта это сделать:
*		1. Компиляция
*		2. Интерпретация
*
* @.'Компилятор' - программа, которая читает код и 'создает' автономную 'исполняемую программу', которую процессор понимает напрямую.
*	1. Преимущество: при повторном запуске программы компиляция не выполняется.
*	Пример: 
*		'Код ЯП				->	Компилятор		->	Исполняемый файл'
*		'Исполняемый файл	->	Процессор		->	Результат программы'
*		(C, C++, Pascal)
*
* @.'Интерпретатор' - программа, которая 'напрямую выполняет код', без его предыдущей компляции в исполняемый файл.
*	1. Преимущество: гибкость
*	2. Недостаток: процесс интерпретации выполняется повторно при каждом запуске программы
*	Пример: 
*		'Код ЯП				->	Интерпретатор	->	Процессор	->	Результат программы'
*		(Perl, JavaScript)
*	(*Java может как компилироваться, так и интерпретироваться)

#endif // Введение в программирование

#ifdef Введение в ЯП С и С++

* @.'Язык С "Си"'
* Разработан в 1972 г. Деннисом Ритчи, как язык для ОС.
*	Цель: минималистичный язык, который предоставлял бы эффективный доступ к памяти, с относительно быстрым выполнением
*	Стандарты:
*		ANSI 	C89
*		ISO		C90
*		ANSI	C99
*
* @.'Язык С++'
* Разработан в 1979 г. Бьёрном Страуструпом в качестве дополнения к Си.
*	Особенность: введение ООП
*	Стандарты:
*		ISO 1998
*		C++03
*		C++11 (* каждые 3 года)
*		C++14
*		C++17
*		C++20
*
* @.'Философия'
* Можно определить выражением "Доверять программисту"
*	Компилятор не будет мешать сделать что-то новое, что имеет смысл,
*		но также не будет мешать сделать что-то такое, что может привести к сбою программы.

#endif // Введение в языки программирования С и С++

#ifdef Введение в разработку ПО

* @.'Схема разработки ПО'
*
*	1.'Определите проблему'
*		Это шаг "Что?"
*		Необходимо понять, что вы хотите, чтобы ваша программа делала
*
*	2.'Разработайте решение'
*		Вопрос "Как?"
*		Каким образом можно решить проблему;
*			довольно часто пренебрегают, способов решения задачи может быть много,
*			только часть из них - хорошие, а часть - плохие
*		Как правило, хорошие решения обладают следующими характеристиками
*			'Простота'
*			'Хорошая документация'
*			'Модульный принцип' (может быть повторна использована, изменена позже)
*			'Надежность' (проверка на ошибки)
*
*	3.'Напишите программу, используя решение'
*
*	4.'Скомпилируйте программу'
*		@.'Работа компилятора' состоит из двух частей:
*			Проверка программы на соответствие правилам языка С++ (проверка синтаксиса)
*			Конвертация каждого исходного файла (*.cpp) с кодом в объектный файл на машинном языке
*
*	5.'Соедините объектные файлы (Линкинг)'
*		@.'Линкинг' - процесс связывания всех объектных файлов, генерируемых компилятором, в единую исполняемую программу.
*		Это делается при помощи программы Линкер / Компоновщик
*		'Исполняемый файл	->	Компиляция	->	Объектный файл	->	 Линкер	->	Исполняемый файл'
*
*	6.'Протестируйте и отладьте программу'
*		При помощи встроенного отладчика; также IDE имеет ряд возможностей:
*			Комплексная помощь
*			Дополнение кода
*			Система контроля версий

#endif // Введение в разработку ПО

#ifdef Режимы конфигурации Debug и Release

* @.'Конфигурация сборки' - это 'набор настроек' проекта, которые определяют принцип его построения.
*	Состоит из:
*		Имени исполняемого файла
*		Имени директории исполняемого файла
*		Имен директорий, в которых IDE будет искать другой код и файлы библиотек
*		Информации об отладке и параметрах оптимизации вашего проекта
* 
* @.'Debug' - предназначен для отладки программы.
*	Отключает все настройки по оптимизации
*	Включает информацию об отладке
* 
* @.'Release' - используется во время сборки программы для её дальнейшего выпуска
*	Оптимизируется по размеру и производительности
*	Не содержит дополнительную информацию об отладке

#endif // Режимы конфигурации Debug и Release

#ifdef Конфигурация компилятора

* Настроим проект Visual Studio для обучения
* Обозреватель решений	
*	->	Свойства (* установить 'Все конфигурации')
*		->	C/C++	
*			->	Общие	
*				->	'Уровень предупреждения 4'
*			->	Язык	
*				->	'Стандарт языка С++ (С++20?)'
*				->	'Отключить расширения языка Да'

#endif // Конфигурация компилятора

#ifdef Структура программ

* @.'Стейтмент' - распространенный тип инструкций, 'наименьшая независимая единица' в языке С++.
* Пример
*	// Стейтмент объявления
*	int x;
*	// Стейтмент присваивания
*	x = 5;
*	// Стейтмент вывода
*	std::cout << x;
* 
* @.'Выражение' - это математический объект, который создается для проведения вычисления и нахождения результата.
* Пример
*	2 + 3
*	2 + x
*	x + y
*	(2 + x) * (y - 3)
* 
* @.'Функция' - это последовательность стейтментов для выполнения определенного задания.
*	Каждая программа в С++ должна содержать главную функцию main(),
*		именно с первого стейтмента, находящегося в функции main() начинается выполнение всей программы.
* Пример
*	Функция max() может содержать стейтменты, для определения наибольшего из заданных чисел.
* 
* #.'Совет'
*	Размещайте функцию main() в файле .cpp с именем, совпадающим с именем проекта
* 
* @.'Библиотека' - это 'набор скомпилированного кода', который был 'упакован' 
*		для повторного использования в других программах
* Пример
*	#include <iostream>
* 
* @.'Пример простой программы'
*	1.	#include <iostream>
*	2.	
*	3.	int main()
*	4.	{
*	5.		std::cout << "Hello, world!";
*	6.		return 0;
*	7.	}
*	
*	Строка №1: 
*		@.'Директива препроцессора' - сообщает компилятору, что ему нужно выполнить определенное задание,
*			в данном случае подключить содержимое файла <iostream>
*
*	Строка №2:
*		Пустое пространство, игнорируется компилятором
*
*	Строка №3:
*		Объявление главной функции main()
*
*	Строка №4 и №7:
*		Указываем компилятору область видимости функции main()
*
*	Строка №5:
*		Стейтмент вывода.
*			std::cout - это специальный объект, используя который мы можем выводить данные на экран
*			<< - это оператор вывода
*			Всё, что отправляется в std::cout - выводится на экран ("Hello, world!")
*
*	Строка №6:
*		Оператор возврата 'return'
*		@.'Код состояния' - когда программа завершает свое выполнение, функция main() передает обратно в ОС
*			значение, которое указывает на результат выполнения программы
*				0 - всё хорошо
*				иначе - что-то пошло не так

#endif // Структура программ

#ifdef Комментарии

* @.'Комментарий' - Это строка/строки текста, вставленные в исходный код,
*		для объяснения того, что этот код делает.
* 
* 'Однострочный комментарий'	-	//
*	Лучше размещать над строками кода
*	Пример
*		// cout и endl находятся в библиотеке iostream
*		std::cout << «Hello, world!» << std::endl;
* 
* 'Многострочный комментарий'	-	/* */
*	Пример
*		/*
*		* Звёздочки слева
*		* упрощают чтение текста
*		*/
*
*		/* Это многострочный комментарий /* */ а это уже не комментарий */
*
* !.'Правило' - Не используйте вложенные комментарии!
* 
* @.'Как правильно писать комментарии?'
*	1. На уровне библиотек/программ/функций комментарии отвечают на вопрос
*		'Что?'
*	Пример
*		// Эта функция использует метод Ньютона для вычисления корня функции
* 
*	2. Внутри библиотек/программ/функций комментарии отвечают на вопрос
*		'Как?'
*	Пример
*		// Чтобы получить рандомный (случайный) элемент, мы выполняем следующее:
* 
*		// 1) Составляем список всех элементов.
*		// 2) Вычисляем среднее значение для каждого элемента, исходя из его веса, цвета и цены.
*		// 3) Выбираем любое число.
*		// 4) Определяем соответствие элемента случайно выбранному числу.
*		// 5) Возвращаем случайный элемент.
* 
*	3. На уровне стейтментов комментарии отвечают на вопрос
*		'Почему?'
*	Пример
*		// Мы решили использовать список вместо массива,
*		// потому что массивы осуществляют медленную вставку.
* 
* @.'Закомментировать код' - корвертировать одну или несколько строк кода в комментарии.
*	Таким образом, исключаем часть кода из компиляции.
*	В Visual Studio 'быстрые клавиши'
*		Закомментировать	-	'Ctrl + K' потом 'Ctrl + C'
*		Раскомментировать	-	'Ctrl + K' потом 'Ctrl + U'
*
* Причины закомментировать код:
*	1. Вы работаете над новой частью кода, которая пока что не рабочая.
*	2. Вы написали код, который компилируется, но работает не так, как нужно
*		и сейчас у вас нет времени с этим возиться.
*	3. Поиск корня ошибки, поочередно отключая части вашего кода.

#endif // Комментарии

#ifdef Объект

* @.'Объект' - это 'часть памяти', которая может хранить значение.
* При создании объекта, часть оперативной памяти выделяется для этого объекта.
* Аналогия
*	Почтовый ящик, куда мы помещаем информацию и откуда ее извлекаем
* 
* @.'Переменная' - Объект с именем.
* Стейтмент a = 8;
*	где 'а' - это переменная.
* 
* Все переменные являются l-values & r-values 
* 'l-values' - значение, которое 'имеет' свой собственный 'адрес' в памяти 
* 'r-values' - значение, 'не имеющего' постоянного 'адреса' в памяти
* (подробнее в следующих уроках)
* 
* Часто путают Инициализацию и Присваивание (?)
* 'Присваивание'
*	int a;
*	a = 8;
* 'Инициализация'
*	int a = 8
* 
* !.'Правило' - Если у вас изначально 'имеется значение' для переменной, то
*	'используйте инициализацию', вместо присваивания
* 
* При объявлении переменной, ей дается ячейка в памяти, при этом в ней будет хранится мусор
*	int a;
*	std::cout << a; // ошибка компиляции (в старых версиях выведет мусор по типу 2362346)

#endif // Объект

#ifdef Параметры и аргументы функций

* @.'Параметр функции' - это 'переменная, которая используется в функции' и значение
*	которой предоставляет caller (вызывающий объект).
* Пример
*	void printValue(int a) // один параметр типа int
*	{
*		std::cout << a << std::endl;
*	}
* 
* @.'Аргумент функции' - это 'значение', которое передается из caller - a в функцию
*	и которое 'указывается в скобках' при вызове функции в caller - e
* Пример
*	printValue(7); // 7 - аргумент функции printValue()
*
* 'Рекомендации при написании функции'
*	1. Код, который появляется более одного раза в программе, лучше переписать в виде функции.
*	2. Код, который используется для сортировки чего-либо, лучше записать в виде отдельной функции.
*	3. Функция должна выполнять одно задание.
*	4. Когда функция становится слишком большой, сложной или непонятной - её следует разбить на несколько подфункций.
*
* @.'Локальная область видимости' - параметры функции, переменные, которые объявлены внутри функции.
*	Создаются в точке объявления и уничтожаются, когда выходят из области видимости.
* 
* !.'Правило' - Имена, которые используются внутри функции (включая параметры),
*	доступны/видны только внутри этой же функции

#endif // Параметры и аргументы функций

#ifdef Ключевые слова и идентификаторы

* @.'Ключевое слово' - Слова в ЯП (С++), зарезервированные для собственного использования
* Пример
*	auto
*	break
*	char
* @.'Идентификатор' - Имя переменной, функции, класса или другого объекта на языке С++.
* !.'Правила' которые нужно соблюдать:
*	1. Идентификатор не может быть ключевым словом.
*	2. Идентификатор может состоять только из букв, цифр и символов подчёркивания
*	3. Идентификатор должен начинаться с буквы
*	4. С++ различает нижний регистр от верхнего (nvalue не тоже самое что nValue)
* Пример 
*	// корректно (разделяется символом подчёркивания)
*	int my_variable_name;
*	void my_function_name();	
* 
*	// корректно (используется CamelCase "Верблюжий Стиль"
*	int myVariableName;
*	void myFunctionName();
* 
*	// некорректно (пробелы запрещены)
*	int my variable name;
*	void my function name();
* 
*	// работает, но не рекомендуется (следует начинать с буквы в нижнем регистре)
*	int MyVariableName;
*	void MyFunctionName();
* 
* #.'Рекомендации':
*	1. При работе с чужим кодом, придерживайтесь его стиля
*	2. Не начинайте ваши имена с символа подчёркивания, они уже зарезервированы для ОС, библиотеки
*		и используются компилятором
*	3. В качестве идентификаторов используйте те имена, которые реально описывают то, чем является объект
*	4. Уточняющий комментарий всегда будет плюсом (иногда выходит слишком длинное название)
* 
* *'Примечание:' Можно использовать тривиальные имена для переменных,
*		которые имеют тривиальное использование (переменные в цикле, простые математич. функции и тд)

#endif // Ключевые слова и идентификаторы

#ifdef Операторы

* @.'Литерал' - это 'фиксированное значение', которое записывается в исходном коде.
* Пример
*	int a = 3;						// a - это переменная, 3 - литерал
*	std::cout << 5 + 2;				// 5 + 2 - выражение, 5 и 2 - литералы
*	std::cout << "Hello, world!";	// "Hello, world!" - тоже литерал
* 
* @.'Операнд' - это 'данные, с которыми работает выражение'
* 
* @.'Оператор' - это спец. 'символы, работающие с операндом' для получения нового значения.
* 
* @.'Операторы бывают трёх типов'
*	1. Унарные		// -7
*	2. Бинарные		// 5 + 2
*	3. Тернарные	// только один ?:

#endif // Операторы

#ifdef Базовое форматирование кода

* Пробелы, используемые для читабельности кода, также игнорируются компилятором
*	(здесь обойдемся без частных случаев)
* 
* #.'Рекомендации':
*	1. Вместо табуляции ('\t') используйте 4 пробела 
*		(для переноса правильных отступов на другие IDE)
* 
*	2. Фигурные скобки
*		На одном уровне
*			int main()
*			{
*			}
*		Или такой вариант
*			int main() {
*			}
* 
*	3. Каждый стейтмент функции должен быть с соответствующим отступом (tab)
*			int main()
*			{
*				std::cout << "Hello, world!" << std::endl;
*				std::cout << "Nice to meet you." << std::endl;
*			}
* 
*	4. Строки не должны быть слишком длинными (?).
*		До 80 символов - это оптимальный максимум строки
* 
*	5. Если длинная строка разбита на части с помощью оператора, то этот оператор должен находиться
*		в конце этой же строки.
*			std::cout << "This is a really, really, really, really, really, really, really, " <<
*				"really long line" << std::endl;
*			if (condition == "firstName" ||
*				condition == "lastName")
* 
*	6. Используйте пробелы и пропуски строк между стейтментами, для улучшения читабельности вашего кода
*			nConst			= 57;
*			nPricePerItem	= 24;
*			nValue			= 5;
*			nNumberOfItems	= 17;

#endif // Базовое форматирование кода

#ifdef Прототип функции и Предварительное объявление

* *'Проблема:'
* int main() {
*	std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
*	return 0;
* }
* 
* int add(int x, int y) {
*	return x + y;
* }
* // add: идентификатор не найден
* // компилятор, находясь в теле main(), еще не знает о функции add(int, int)
* 
* 
* @.'Предварительное объявление' - 'сообщает компилятору о существовании идентификатора' ДО 
*		его фактического определения
* Пример
*	int add(int x, int y) {
*		return x + y;
*	}
* 
*	int main() {
*		std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
*		return 0;
*	}
* 
* @.'Прототип функции' - состоит из типа возврата функции, её имени и параметров.
*	В кратком прототипе можно опустить имена параметров функции
* Пример 
*	int add(int, int);	
* 
*	int main() {
*		std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
*		return 0;
*	}
* 
*	int add(int x, int y) {
*		return x + y;
*	}
* 
* 
* @.'Определение' - вызывает выделение памяти для идентификатора.
* Пример
*	int add(int x, int y)	// определяем функцию z
*	{
*		int z = x + y;		// определяем переменную z
*		return z;
*	}
* !.'Правила':
*	1. Внутри файла функция/объект/тип/шаблон могут иметь только 'одно определение'
*	2. Внутри программы объект/функция могут иметь только 'одно определение'
*	3. Внутри программы типы/шаблоны функций/встроенные функции могут иметь 'несколько определений',
*		'если' они 'идентичны'
*	Нарушение правила 1 - ошибка компиляции
*	Нарушение правила 2 или 3 - ошибка линкинга
*
* @.'Объявление' - это стейтмент, который сообщает компилятору о существовании идентификатора и о его типе.
* Пример
*	int add(int x, int y);	// объявляем функцию add
*	int x;					// объявляем переменную x
* 
* 'Определение' - это то, что 'обеспечит' корректную работу как 'компилятора', так и 'линкера'
* 'Объявление' - всё, что необходимо 'для' корректной работы 'компилятора', 'но недостаточно для' корректной работы 'линкера'

#endif // Прототип функции и Предварительное объявление

#ifdef Директивы препроцессора

* @.'Препроцессор' - отдельная программа, которая 'выполняется перед компиляцией'.
* При запуске программы, препроцессор просматривает код сверху вниз, файл за файлом, в поиске директив.
* 
* @.'Директивы' - 'специальные команды', которые начинаются с символа '#' и НЕ заканчиваются ';'
* 
* 'Директива #include' - препроцессор 'копирует содержимое подключаемого файла' 
*	в текущий файл сразу после строки с #include
*		Угловые скобки < >
*			Сообщает препроцессору искать файл в 'системных путях'
*			#include <filename>
*		Двойные кавычки " "
*			Сообщает препроцессору искать файл в 'текущей директории проекта'
*			#include "filename"
* 
* 'Директива #define' - используется для создания макросов
* 
* @.'Макрос' - это правило, которое определяет 'конвертацию идентификатора в указанные данные'.
*	Есть два типа макросов
*		'Макросы-функции' ведут себя как функции и используются в тех же целях.
*		'Макросы-объекты' 
*			Пример
*			#define MY_FAVORITE_NUMBER 9	// MY_FAVORITE_NUMBER заменяется числом 9
*			#define USE_YEN					// USE_YEN заменяется пустым местом
*				'Не рекомендуется использовать как замену!'
*					1. Из-за глобальной области видимости
*					2. Из-за невозможности увидеть заменяемое значение в отладчике
*
* @.!'Правило:' Не используйте директиву #define для создания символьных констант
* 
* 'Директива условной компиляции'
*	#ifdef		// Было ли определено с помощью #define?
*	#ifndef		// Было ли НЕ определено с помощью #define?
*	#endif		// Конец условной компиляции
* Пример ('Header Guards')
*	@.'Header Guards'
*	Часто используется в '.h' файлах, для предотвращения копирования одного и того же файла.
*		#ifndef SOME_UNIQUE_NAME_HERE
*		#define SOME_UNIQUE_NAME_HERE
*
*		// Основная часть кода
* 
*		#endif
* 
*	#pragma once - альтернатива примеру выше, короче и менее подвержена ошибкам.
*		НО, не является официальной частью языка С++ и не все компиляторы её поддерживают.
*		Поэтому рекомендуется использовать Header Guards (?)

#endif // Директивы препроцессора

#ifdef Конфликт имен и std namespace

* Большинство конфликтов имен происходят в двух случаях:
*	1. Файлы добавленные в один проект, имею функцию с одинаковыми именами (линкинг)
*	2. Файл .cpp подключает заголовочный файл, в котором идентификатор конфликтует с 
*		идентификатором из файла .cpp (компиляция)
* 
* Весь функционал Стандартной библиотеки С++ определен внутри пространства имен std (сокр. от "standart")
* 
* @.'Оператор разрешения области видимости ::' - способ сообщить компилятору, что идентификатор находится в 
*	определенном пространстве имен.
* Пример
*	// Сообщаем, что хотим использовать cout из пространства имен std
*	std::cout << "Hello, world!";

#endif // Конфликт имен и std namespace

#ifdef Разработка ваших первых программ

* Шаг №1: 'Определите проблему'
*	Сформулировать проблему, которая решит ваша задача.
*	Пример
*		Я хочу написать программу-справочник для удобного хранения и редактирования
*			всех телефонных номеров и звонков.
* 
* Шаг №2: 'Определите свой инструментарий, цели и план бэкапа'
*	Для опытных будет не мало дополнительных пунктов:
*		Какая ваша целевая аудитория и какие у нее потребности?
*		На какой архитектуре/ОС ваша программа будет работать?
*		Какой инструментарий вы будете использовать?
*		Будете ли вы разрабатывать программу в одиночку или в составе команды?
*		Анализ требований.
*		Определение стратегий тестирования/обратной связи/релиза.
*		Создание плана бэкапа в случае неожиданных проблем.
* 
* Шаг №3: 'Разбейте проблему на части'
*	Любое сложное — это совокупность множества простого.
*	Задача: 
*		Написать доклад о картошке
*	Разделим на подзадачи:
*		Написать доклад о картошке
*			Поиск информации о картошке
*			Создание плана
*			Заполнение каждого пункта плана подробной информацией
*			Заключение
*	Звучит всё еще расплывчато - разобьем подпункты:
*		Написать доклад о картошке
*			Поиск информации о картошке
*				Сходить в библиотеку за книжками о картошке
*				Поискать информацию в Интернете
*				Делать заметки в соответствующих разделах из справочного материала
*			Создание плана
*				Информация о выращивании
*				Информация об обработке
*				Информация об удобрениях
*			Заполнение каждого пункта плана подробной информацией
*			Заключение
* 
* Шаг №4: 'Определите последовательность событий'
*	Надо определить, как связать все пункты вместе.
*	Также стоит учесть, что для выполнения одной задачи, может потребоваться выполнение другой.
* 
* Шаг №5: 'Определите данные ввода и данные вывода на каждом этапе'
* Шаг №6: 'Позаботьтесь о деталях'
* Шаг №7: 'Соедините данные ввода с данными вывода в программе'

#endif // Разработка ваших первых программ

#ifdef Отладка программ

* Типы ошибок
*	@.'Синтаксическая ошибка' - когда вы пишете код, которые не соответствует правилам грамматики ЯП С++
*	@.'Семантическая ошибка' - когда код синтаксически правильные, но делает не то, что задумал программист
* 
* @.'Отладчик'/'Дебаггер' - программа, которая позволяет программисту 'контролировать выполнение кода'.
*	Например, для выполнения программы пошагово, последовательно изучая значения переменных в программе.
* 
* 'Примечание:' убедитесь, что вы находитесь в режиме конфигурации Debug
* 
* @.'Степпинг' - возможность отладчика выполнять код пошагово (строка за строкой).
*	Есть три команды степпинга:
*		'Шаг с заходом'							| F11
*		'Шаг с обходом'							| F10
*		'Шаг с выходом'							| shift + F11
* 
* Команда "Выполнить до текущей позиции"		| ПКМ по строке и Выполнить до текущей позиции
*	Выполнит весь код до строки, обозначенной курсором.					
* 
* Команда "Продолжить"							| F5
*	Продолжит выполнение до конца программы или до следующей контрольной точки.
* 
* @.'Точка останова' - 'специальные маркеры',	| ЛКМ по свободной зоне слева от номера строки
*	на которых отладчик 'останавливает процесс выполнения' программы.
* 
* @.'Отслеживание переменных' - это процесс проверки значений переменных во время отладки.
* @.'Стек вызовов' - это список всех активныхз функций, которые вызывались до текущего местоположения.
*	'Отладка'	->	'Окна'	->	'Стек вызовов'

#endif // Отладка программ

#ifdef Инициализация, присваивание и объявление переменных

* С++ поддерживает 3 основных способа инициализации переменных.
*	1. Копирующая инициализация
*		int nValue = 5;
*	2. Прямая инициализация
*		int nValue(5);
*	3. uniform-шнициализация
*		Преимущество: компилятор выдаст предупреждение или сообщение об ошибке.
*			int nValue{5};
*			// по умолчанию значение 0
*			int nValue{}
*			Преимущество:
* 
* !.'Правило:' Используйте uniform-шнициализацию
* 
* Объеявление нескольких переменных:
*	int a, b;
* 
*	int a;
*	int b;
* 
* !.'Правило:' Объявляйте переменные как можно ближе к их первому использованию.

#endif // Инициализация, присваивание и объявление переменных

#ifdef Тип данных void

* @.'void' - тип данных, который означает 'отсутствие любого типа данных'
* 
* Переменные не могут быть типа void
* 
* Использование:
*	1. Функция не возвращает значения
*		void writeValue(int x)
*	2. Функция не имеет никаких параметров (перешло из Си)
*		int getValue(void)	<=>	int getValue()
*	3. Указатели типа void // не рекомендуется (?)
*		@.'Указатели типа void' - специальный тип указателя, который может указывать на объекты
*			'любого типа' данных!
*		Для разыменовывания нужно будет прежде преобразовать с помощью олератора static_cast 		

#endif // Тип данных void

#ifdef Тип данных

* 'Категория'						'Тип'				'Минимальный размер'
* Логический тип данных				bool				1Б
* 
* Символьный тип данных				char				1Б
*									wchar_t				1Б
*									wchar16_t			2Б
*									wchat32_t			4Б
* 
* Целочисленный тип данных			short				2Б
*									int					2Б
*									long				4Б
*									long long			8Б
* 
* Тип данных с плавающей запятой	float				4Б
*									double				8Б
* 									long double			8Б
* 
* 
* 'Про целочисленные типы:'
* @.'Оператор sizeof' - унарный, вычисляет и возвращает 'размер' переменной или определенного типа
*		'данных' в байтах
* 
* @.'Ключевое слово signed' - обозначает, что переменная может содержать '+' и '-' значения.
*	По умолчанию перед типом пишется signed
* 
* @.'Ключевое слово unsigned' - обозначает, что переменная может содержать только '+' значения.
* 
* Диапазон значений (пример)
*	1Б signed			-128	:	127
*	1Б unsigned		0		:	255
* 
* !!!Как правило, unsigned избегают, из-за непредвиденных ошибок.
*	(при смешивании signed и unsigned)
* 
* @.'Переполнение' - 'потеря бита' из-за того, что переменной 'не было выделено достаточно памяти' для их хранения.
* Пример
*	4-битная переменная:
*		21 = 0b10101 (двоичный вид)
*			крайний левый бит потеряется, поскольку выделено 4 бита.
*			получим: 0b0101 = 5
* 
* !.'Правило:' Никогда не допускайте возникновения переполнения в ваших программах!
* 
* При делении 'целых' чисел в C++ дробная часть 'отбрасывается!'
* Пример
*	// Знаем
*	8 / 5 = 1.6
*	// Компьютер
*	8 / 5 = 1
* 
* Размер целочисленных типов не является фиксированным,
*	началось с языка Си, когда производительность имела первостепенное значение,
*	чтобы компилятор мог самостоятельно подобрать наиболее подходящий размер для определенного
*	типа данных в зависимости от компьютерной архитектуры.
* 
* В С++ добавили набор целочисленных типов фиксированного размера
*	int8_t	uint8_t
*	int16_t	uint16_t
*	int32_t	uint32_t
*	int64_t	uint64_t
* 
*	*До С++11 требуется подключить <stdint.h>
* 
*	*'Предупреждение', int8_t uint8_t могут быть обработаны как тип char
* 
* 
* 'Про типы данных с плавающей точкой:'
* Следует знать, как правильно писать литералы:
*	5		-	int
*	5.0		-	double
*	5.		-	double
*	5.0f	-	float
*	5.f		-	float
* 
* 'Экспоненциальная запись'
*	5000.0		=	5e3
*	0.05		=	5e-2
*	42030		=	4.203e4		// отбрасываем последний 0
*	0.0078900	=	7.8900e-3	// из дробной части 0 не отбрасывается
* 
* Можем переопределить 'точность' cout, используя функцию std::setprecision(),
*	которая находится в заголовочном файле <iomanip>
* Пример
*	float f		=	3.33333333333333333333333333333333333333f;
*	double d	=	3.33333333333333333333333333333333333333;
*	std::cout << std::setprecision(17);
*	std::cout << f << std::endl;
*	std::cout << d << std::endl;
* Вывод:
*	3.3333332538604736
*	3.3333333333333335
* 
* 'Ошибки округления'
* Пример
* double a{1.0};
* double b{0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1};
* std::cout << a << '\n' << b << std::endl;
* Вывод:
*	1
*	0.99999999999999989
* 
* @.'Сравнение чисел с плавающей запятой'
* Пример 'Различных разработчиков'
*	include <cmath>
*	bool isAlmostEqial(double a, double b, double epsilon) {
*		return fabs(a - b) <= epsilon;
*	}
* Недостаток: всегда нужно подбирать нужны epsilon
* 
* Пример 'Кнута'  
*	include <cmath>
*	bool approximatelyEqual(double a, double b, double epsilon) {
*		return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
*	}
* Преимущество: epsilon представляет собой процентное соотношение.
* Недостаток: сравнение чисел близких к нулю
* 
* Пример 'Всё вместе'
*	#include <cmath>
*	bool vmeste(double a, double b, double absEpsilon, double relEpsilon) {
*		double diff = fabs(a - b);
*		if (diff <= absEpsilon)
*			return true;
* 
*		return diff <= ((fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * relEpsilon);
*	}
*
* 'nan и inf'
*	inf - бесконечность
*	nan - не число (несколько видов)
* Пример
*	double zero = 0.0;
*	double posinf = 5.0 / zero;
*	double neginf = 5.0 / zero;
*	double nan = zero / zero;
*	std::cout << 
*		posinf << '\n' <<
*		neginf << '\n' <<
*		nan << std::endl;
* Вывод
*	inf
*	-inf
*	-nan(ind)
* 
* 
* 'Про логический тип данных:'
* Чтобы std::cout выводил true или false, используйте манипулятор std::boolalpha
*	std::cout << std::boolalpha;
* 
* В С++ нет 'XOR', можно сымитировать, используя оператор неравенства (!=)
* if (a != b) ... // a XOR b (предполагается, что a и b типа bool)
*
* 'Про char'
* Интерпретируется как ASCII-символ
*	(существует таблица, где числам от 0 до 127 назначен свой символ)
*	Пример
*		char ch(5);		// инициализация целым числом 5
*		char ch('5');	// инициализация символом '5' (не тоже самое)
* 
* @.'Оператор static_cast' - лучший 'способ конвертации переменной' из одного типа данных в другой
* Пример
*	char ch(97)
*	std::cout << ch << std::endl;
*	std::cout << static_cast<int>(ch) << std::endl;
* Вывод
*	a
*	97
* 'Примечание:' У static_cast 'нет проверки' на диапазон значений; 
*	мы можем случайно вызвать 'переполнение'.
* 
* @.'Управляющие символы' - Начинаются с '\', имеют свое назначение.
*	'Название'					'Символ'		'Значение'
*	Предупреждение				\a				Звуковой сигнал
*	Backspace					\b				Перемещ. курсора на одну позицию назад
*	Formfeed					\f				Перемещ. курсора к следующей логич. странице (?)
*	Newline						\n				Перемещ. курсора на следующую строку
*	Carriage Return				\r				Перемещ. курсора в начадл строки
*	Horizontal tab				\t				Вставка горизонтального TAB-a
*	Vertical tab				\v				Вставка вертикального TAB-a
*	Одинарная кавычка			\'				'Вставка одинарной кавычки (или апострофа)
*	Двойная кавычка				\"				"Вставка двойной кавычки
*	Бэкслеш						\\				Вставка обратной косой черты
*	Вопросительный знак			\?				Вставка знака вопроса
*	Восьмеричное число			\(number)		Перевод числа из восьмеричной СС в тип char
*	Шестнадцатеричное число		\x(number		Перевод числа из шестнадцатеричной СС в тип char
* 
* '\n' vs std::endl;
*	Преимущество 'std::endl очищает буфер'
*		Используйте std::endl в случаях, где нужно, чтобы данные выводились сразу же
*			* Запись в файл
*			* При обновлении индикатора состояния процесса
*		'\n' - во всех остальных случаях
	
#endif // Тип данных

#ifdef Константы

* !.'Правило:' Любая переменная, которая не должна изменять свое значение после инициализации,
*	должна быть объявлена с помощью спецификатора const или constexpr
* 
* Константы объявляются с 'инициализацией'.
* 
* Есть два вида констант:
*	Константа времени выполнения ('const')
*		- значение определится во время выполнения программы
*	Константа времени компиляции ('constexpr')
*		- значение определится во время компиляции программы
* 
* 'Алгоритм использования символьных констант:'
*	1. Создать 'заголовочный файл' для хранения констант.
*	2. В заголовочном файле объявить пространство имён.
*	3. Добавить все константы в созданное пространство имён.
*	4. #include этот файл везде, где нужны константы.
* Пример 
*	"constants.h"
*		#ifndef CONSTANTS_H
*		#define CONSTANTS_H
*		
*		namespace constants
*		{
*			const double pi{ 3.14159 };
*		}
* 
*		#endif CONSTANTS_H
* 
*	".cpp файл"
*		#include "constants.h"
* 
*		//...
*		double circumference = 2 * radius * constants::pi;
*		//...		

#endif // Константы

#ifdef Операторы

* // Тут мне стало лень
* !.'Правило:' Используйте 'префиксный' инкремент и 'префиксный' декремент вместо
*		постфиксного инкремента и постфиксного декремента.
* 
* #.'Совет:' Всегда заключайте в скобки условную часть тернарного оператора, а
*		лучше весь тернарный оператор.

#endif // Операторы

#ifdef Побитовые операторы

* @.'Таблица побитовых операторов'
*	'Оператор'					'Символ'
*	Побитовый сдвиг влево		<<		
*	Побитовый сдвиг вправо		>>		
*	Побитовое НЕ				~		
*	Побитовое И					&		
*	Побитовое ИЛИ				|		
*	Побитовое исключающее ИЛИ	^
* 
* !.'Правило:' При работе с побитовыми операторами используйте целочисленные типы данных unsigned.
* 
* См. примеры на "binary.h"
* 
* 'Битовые флаги'
*	const unsigned char option1 = 0x01; // шестнадцатеричный литерал для 0000 0001
*	const unsigned char option2 = 0x02; // шестнадцатеричный литерал для 0000 0010
*	const unsigned char option3 = 0x04; // шестнадцатеричный литерал для 0000 0100
*	const unsigned char option4 = 0x08; // шестнадцатеричный литерал для 0000 1000
*	const unsigned char option5 = 0x10; // шестнадцатеричный литерал для 0001 0000
*	const unsigned char option6 = 0x20; // шестнадцатеричный литерал для 0010 0000
*	const unsigned char option7 = 0x40; // шестнадцатеричный литерал для 0100 0000
*	const unsigned char option8 = 0x80; // шестнадцатеричный литерал для 1000 0000
* Пример
*	unsigned char myflags = 0; // все флаги/параметры отключены до старта
*	
*	myFlags |= option4;					// включаем option4
*	myFlags |= (option4 | option5);		// включаем option4 и option5
* 
*	myFlags &= ~option4;				// выключаем option4
*	myFlags &= ~(option4 | option5);	// выключаем option4 и option5
* 
*	myFlags ^= option4;					// изменить состояние option4
*	myFlags ^= (option4 | option5);		// изменить состояние option4 и option5
* 
* @.'bitset'
*	#include <bitset>
* Пример
*	std::bitset<8> bits;
*	std::bitset<8> bits(option1 | option2); // начнем с включенных option1 и option2
*	std::bitset<8> morebits(0x2) ; // начнем с битового шаблона 0000 0010
* 'Функции'
*		test()		-	узнать значение бита
*		set()		-	включить бит
*		reset()		-	выключить бит
*		flip		-	перевернуть бит
* 
* @.'Битовые маски' - запрашивание сразу нескольких бит, в целях их модификации как группы.
*
* 'САМОПИСНЫЙ ПРИМЕР' см.
*	"binary.h"
*	"binary.cpp"

#endif // Побитовые операторы

#ifdef Область видимости
* @.'Блоки стейтментов' - группа стейтментов, которые обрабатываются компилятором как одна инструкция.
* Начинается с символа '{' и заканчивается символом '}' 
* Пример
* int main() 
* // внешний блок
* {
*	// переменная m создается и инициализируется здесь
*	int m(4); 
*	// начало вложенного блока
*	{
*		// переменная k создается и инициализируется здесь
*		double k(5.0);
*	} 
*	// Переменная k не может быть использована здесь, так как она уже уничтожена!
* 
* @.'Уровень вложенности блоков' - максимальное количество блоков, которые могут находиться в любой точке функции.
* 
* @.'Сокрытие имен'
* Пример
* int main() {
*	// внешняя переменная oranges
*	int oranges(5);
*	if (oranges >= 5)
* 
*	// вложенный блок
*	{
*		// скрывается внешняя переменная oranges
*		int oranges; 
*		// здесь мы присваиваем значение 10 вложенной переменной oranges, не внешней!
*		oranges = 10; 
*		// выводим значение вложенной переменной oranges
*		std::cout << oranges << std::endl;
*	// вложенная переменная oranges уничтожается
*	}
*	
*	// Идентификатор oranges опять относится к внешней переменной oranges
*	std::cout << oranges << std::endl; // выводим значение внешней переменной oranges
* 
* 
* @.'Глобальные переменные' - переменные, объявленные 'вне блока'.
* При одинаковых именах, можно компилятору сообщить, какую версию использовать при помощи оператора ::
* Пример
* int value{ 8 };
* int main() {
*	int value = 8;
*	value++;		// увеличивается локальная переменная
*	::value--;		// уменьшается глобальная переменная
* 
*	std::cout << "Global value: " << ::value << '\n';
*	std::cout << "Local value: " << value << '\n';
*
* @.'Область видимости' - олпределяет, где 'доступен идентификатор' для использования.
*	1. Локальная/блочная область видимости: доступны только в пределах блока, в котором они объявлены
*			Локальные переменные
*			Параметры функции
*	2. Глобальная/файловая область видимости: доступны в любом месте файла
*			Глобальные переменные
* 
* @.'Продолжительность жизни' - определяется, где 'создается' и где 'уничтожается' переменная
*	1. Автоматическая: создаются в точке определения и уничтожаются при выходе из блока.
*			Локальные переменные
*	2. Статическая: когда программа запускается и уничтожаются при ее завершении.
*			Глобальные переменные
*			Статические локальные переменные
*	3. Динамическая: создаются и уничтожаются по запросу программиста
*			Динамические переменные
* 
* @.'Связь' - определяет, относятся ли 'несколько упоминаний одного идентификатора' к одному и тому же идентификатору или нет.
*	1. Без связей: ссылаются сами на себя.
*			Локальные переменные
*			Пользовательские типы данных (enum, typedef и классы, объявленные внутри блока)
*				int x;
*				static int x;
*				int *x = new int;
*				void foo(int x);
*	2. Внутренняя связь: доступны в любом месте файла, в котором они объявлены.
*			Статические глобальные переменные
*			Константные глобальные переменные
*			Статические функции
*				static int g_x;
*				const int g_x(1);
*	3. Внешняя связь: доступны в любом месте файла, в котором они объявлены, так и в других файлах (через предварит. объявление)
*			Обычные функции
*			Неконстантные глобальные переменные
*			Внешние константные глобальные переменные
*			Определяемые пользователем типы данных (enum, typedef и классы с глобальной областью видимости)
*				int g_x;
*				extern const int g_x(1)
* 
* @.'Переменная без связей' - переменная с 'локальной' областью видимости, которая относится 'только к блоку'
*	в котором она определена
* 
* @.'Статическая переменная' - переменная, имеющая внутренние связи, может использоваться только 'внутри файла'
*	Ключевое слово static
* 
* @.'Внешняя переменная' - переменная, имеющая внешние связи, может использоваться во всех файлах
*	Ключевое слово extern
*	Чтобы использовать, необходимо предварительное объявление переменной с использованием ключевого слова extern
* 
* #.'По умолчанию:' 
*		Переменная объявленная вне блока - extern (внешние)
*		НО константные переменные вне блока - static (внутренние)
*		Функции - extern
* 
* #.'Объявление констант extern:'
* Пример
*	"constants.h"
*		namespace Constants
*		{
*			extern const double pi;
*			extern const double avogadro;
*			extern const double gravity;
*		}
*	"constants.cpp"
*		namespace Constants
*		{
*			extern const double pi(3.14159);
*			extern const double avogadro(6.0221413e23);
*			extern const double gravity(9.2);
*		}
*	Преимущество: любые изменения, сделанные в constants.cpp, потребуют перекомпиляции только этого файла
*	Недостаток: такие костанты не будут считаться константами типа compile-time
* 
* #.'Совет:' Используйте префикс - 'g_' для идентификации неконстантных глобальных переменных
*	(а лучше эти переменные не использовать - '//')
*	Если используем:
*		инкапсулируем, делая переменную static и получая доступ через функции,
*		сводим случаи, где эти переменные могут измениться к минимуму!
*	
* 'САМОПИСНЫЙ ПРИМЕР' см. 
*	"global.h"
*	"global.cpp"

#endif // Область видимости

#ifdef using

* @.'using-объявление'
* int main() {
*	// using-объявление сообщает компилятору, что cout следует обрабатывать как std::cout
*	using std::cout;
*	cout << "Hello, world!";
* }
* 
* @.'using-директива' (стараться избегать)
* int main() {
*	// using-директива сообщает компилятору, что мы используем все объекты из пространства имен std
*	using namespace std;
*	cout << "Hello, world!";
* }
* Пример конфликта
*	#include <iostream>
* 
*	int cout() { 
*		return 4;
*	}
* 
*	int main() {
*		using namespace std;
*		cout << "Hellom world!";
*	}
* 
* !.'Правило:' Ограничивайте using-стейтменты при помощи локальной области видимости { }

#endif // using

#ifdef Преобразование типов

* @.'Неявное преобразование типов' - всякий раз, когда требуется один тип данных, а предоставляется другой и 
*	пользователь не указывает компилятору, как выполнить конвертацию.
*		1. 'Числовое расширение'	|	Безопасно, не приводит к потере данных
*			* С плавающей точкой
*				float -> double
*			* Интегральное
*				int -> long
*		2. 'Числовая конверсия'		|	Может привести к переполнение, потере точности и тд
*				double -> float
*				int -> char
* 
* Приоритет типов операндов:
*	long double			(самый высокий)
*	double
*	float
*	unsigned long long
*	long long
*	unsigned long
*	long
*	unsigned int
*	int					(самый низкий)
* 
* Пример
*	short x(3);
*	short y(6);
*	std::cout << typeid(x + y).name() << " " << x + y << std::endl;
*	// Поскольку short меньше по размеру/диапазону типа int, то он подвергается интегральному расширению в тип int
*	Результат: int 9
* 
*	double x(3.);
*	short y(2);
*	std::cout << typeid(x + y).name() << " " << x + y << std::endl;
*	// short подвергается интегральному расширению в int
*	// поскольку int и double не совпадают, но double находится выше в иерархии типов, то целое число 2 теперь 2.0 типа double
*	Результат: double 5
* 
*	std::cout << 5u - 10;
*	// здесь int (signed int) подвергается расширению в unsigned int (по приоритету)
*	// знаем, что первый бит у int'a используется для определения знака (0000'0000'0000'0101 - 1000'0000'0000'1010
*	Результат: 4294967291
*	Чтобы подробнее расмотреть это, используйте следующий код:
*		#include <iostream>
*		#include <bitset>
*		int main() {
*			unsigned int a		= 5u;
*			int b				= -10;
*			unsigned int result	= a + b;
*			std::bitset<16> binA(a), binB(b), binResult(result);
*			std::cout <<
*				binA << '\n' << 
*				binB << '\n' << 
*				binResult << '\n';
*		}
* 
* @.'Явное преобразование' - используя оператор явного преобразования, указать компилятору как выполнить преобразование
*	5 видов операций:
*		C-style
*			(int)x или
*			int(x)
*			! Не проверяется во время компиляции, лучше не использовать
*		static_cast
*			static_cast<int>(x)
*		const_cast
*		dynamic_cast
*		reinterpret_cast
* 

#endif // Преобразование типов

#ifdef Перечисления

* @.'Перечисление' - тип данных, где любое 'значение' определяется как 'символьная константа'.
*	enum Colors
*	{
*		COLOR_RED,		// 0
*		COLOR_GREEN,	// 1
*		COLOR_BLUE		// 2
*	};
* 
* Объявление перечислений не требует памяти!
* Выделяется только когда переменная определена.
* 
* Можно: 
*	присваивать целочисленные значение
*	не присваивать значения
*	явно присваивать значения с плавающей точкой
*	присваивать значения предыдущих перечислителей
* 
* Могут быть:
*	отрицательными
*	не уникальными
* 
* @.'enum class' - перечисление с областью видимости
*	enum class Fruits { 
*		LEMON 
*	};
*	enum calss Colors { 
*		PINK 
*	};
*	Fruits fruit = Fruits::LEMON;
*	Colors color = Colors::PINK;
*
*	// ошибка компиляции, поскольку компилятор не знает, как сравнивать разные типы: Fruits и Colors
*	// без слова class был бы true, if (0 == 0)
*	if (fruit == color) { 
*		...
*	}

#endif // Перечисления

#ifdef typedef и type alias

* @.'typedef' - ключевое слово, позволяет создать псевдоним для любого типа данных
* Пример
*	typedef double time_t;
*	// следующие два стейтмента эквивалентны
*	double howMuch;
*	time_t howMuch;
* 
* 'Поддержка кода'
*	Если вы использовали тип short, но потом решили заменить на long:
*		Не придется шерстить кучу кода для замены short -> long, а просто заменить typedef
* 'Кроссплатформенность'
*	На некоторых платформах int занимает 2 байта, на других - 4 байта:
*		Вспомним про int8_t - это 8-битный signed int, и тд int16_t, int32_t.
* 'Упрощение сложного'
*	Можем увидеть следующее: 
* 
*	std::vector<std::pair<std::string, int>> pairlist;
* 
*	boolean hasAttribute(std::vector<std::pair<std::string, int>> pairlist) {
*		...
*	}
* 
*	Лучше:
*	typedef std::vector<std::pair<std::string, int>> pairlist_t
* 
*	pairlist_t pairlist;
* 
*	boolean hasAttribute(pairlist_t pairlist) {
*		...
*	}
* 
* Легко забыть 
*	typedef time_t double; // неправильно
*	typedef double time_t; // правильно
* 
* @.'type alias' - улучшенный синтаксис для typedef (C++11), который имитирует способ объявления переменных.
* Пример
* // typedef double time_t;
* using time_t = double;
* 
* !.'Правило:' Используйту type alias вместо typedef, если C++11

#endif // typedef и type alias

#ifdef struct

* @.'Структура' - пользовательский тип данных, группируют несколько отдельных переменных вместе.
* Пример
*	struct Employee
*	{
*		short id;
*		int age;
*		double salary;
*	};
* 
*	// john.id = 5
*	// john.age = 27
*	// john.salary = 0.0 (по умолчанию)
*	Employee john = { 5, 27 };
*	Employee john { 5, 27 };	// С++11
* 
* 'C++11'
*	1. Возможность установить значения по умолчанию
*		struct Triangle
*		{
*			double length = 2.0;
*			double width = 2.0;
*		};
* 
*	2. Возможность присваивать значения членам структур, используя список инициализаторов
*		Employee john;
*		john = { 5, 27, 45000.0 }
;
*	3. Uniform-инициализация
*		Employee john { 5, 27 };
* 
* 'С++14'
*	Совместимость инициализации нестатических членов структуры с списком иницализаторов или uniform-инициализаций.
*		struct Triangle
*		{
*			double length = 2.0; // нестатическая инициализация членов
*			double width = 2.0;
*		};
*		Triangle z = { 3.0, 3.0 }; // До С++11 включительно ошибка компиляции

#endif // struct

#ifdef Операторы управления потоком выполнения программ

* При запуске ЦП начинает выполнение кода с первой строки функции main();
* 
* @.'Порядок выполнения программы' (поток выполнения программы) - 
*		последовательность стейтментов, которые выполняет ЦП.
* 
* @.'Остановка' - сообщает программе немедленно прекратить свое выполнение.
*	#include <cstdlib> // для функции exit() 
*		которая возвращает целочисленный параметр в ОС в качестве выхода. 
* 
* @.'Прыжок' - сообщает компилятору перейти от одного стейтмента к другому.
*	ключевые слова goto, break, continue
*	вызовы функций
* 
* @.'Условное ветвление' - позволяет программу изменить свой порядок выполнения
* 
* @.'Цикл' - заставляет программу многократно выполнять определенное количество стейтментов.
*	while, do while, for, foreach (C++11)
* 
* @.'Исключения' - механизм обработки ошибок, возникающих в функции.
*	может выбросить исключение -> цп перейдет к ближнему блоку кода, который обрабатывает это исключение

#endif // Операторы управления потоком выполнения программ

#ifdef Генератор псевдослучайных чисел

* @.'Хороший ГПСЧ должен иметь ряд свойств:'
*	1. Генерировать каждое новое число с примерно одинаковой вероятностью
*	2. Метод, с помощью которого генерируется следующее число в последовательности,
*		не должен быть очевиден и предсказуем.
*	3. Должен иметь хорошее диапазонное распределение чисел.
*	4. Период повторений значений должен быть максимально большим
* 
* 'Самописный вариант'
* Пример
* unsigned int random() {
*	static unsigned int seed = 4541;
*	seed = (8253729 * seed + 2396403);
*	return seed % 32768;
* }
* 
* 
* 'srand() и rand()'
* @.'srand()' - устанавливает передаваемое значение в качестве стартового.
* @.'rand()' - генерирует случайное число в последовательности от 0 до RAND_MAX (константа в cstdlib)
* Недостаток: узкий диапазон (до 32767 - RAND_MAX)
* Пример
* #include <cstdlib>
* unsigned int random() {
*	return rand();
* }
* int main() {
*	srand(4541);
* }
* 
* 
* 'Добавляем time() в качестве стартового числа'
* Проблема:
*	При одном и том же стартовом числе, получаем одинаковую последовательность.
* Решение:
*	Использовать системные часы в качестве стартового числа
*	@.'time()' - возвращает в качестве времени общее количество секунд, прошедшее от полуночи 1 января 1970 г.
* Пример
* #include <cstdlib>
* #include <ctime>
* unsigned int random() {
*	return rand();
* }
* int main() {
*	srand(static_cast<unsigned int>(time(0)));
* }
* 
* 
* 'Случайные числа в заданном диапазоне'
* Пример 'Ravesli'
* unsigned int getRandomNumber(int min, int max) {
*	static const double fraction = 1.0 / (static_cast<double>(RAND_MAX) + 1.0);
*	return static_cast<int>(rand() * fraction * (max - min + 1) + min);
* }
* Пример самописный
* unsigned int getRandomNumber(int min, int max) {
*	return static_cast<int>(rand() % max + min);
* }
* 
* 
* @.'Вихрь Мерсенна' (C++11)
* Преимущество: широкий диапазон (32-битные целые числа unsigned и существует версия std::mt19937_64)
* Пример
* #include <random>
* unsigned int random(std::mt19937& seed) {
*	return seed() % 6 + 1;
* }
* 
* int main() {
*	std::random_device rd;
*	std::mt19937 seed(rd());
* }

#endif // Генератор псевдослучайных чисел

#ifdef Обработка некорректного пользовательского ввода

* @.'std::cin' 
*	Когда пользователь вводит данные в ответ на операцию извлечения, то эти данные помещаются 
*		в буфер std::cin
* @.'Буфер данных' - часть памяти, зарезервированная для временного хранения.
*	'>>' - оператор извлечения
*	При использовании оператора извлечения (>>), выполняется следующая процедура:
*		1. Если во входном буфере есть данные, то эти данные используются для извлечения
*		2. Если во входном буфере нет данных, то пользователю предлагается ввести данные.
*			* Когда пользователь нажимает Enter, символ новой строки '\n' помещается во входной буфер
*		3. Оператор >> извлекает данные из входного буфера в переменную, сколько позволяет размер самой переменной
*			* Игнорируя любые пробелы, '\t' и '\n'
*		4. Любые данные, которые не были извлечены, остаются во входном буфере.
* Пример
* #include <iostream>
* double getValue() {
*	while (true)
*	{
*		std::cout << "Enter a double value: ";
*		double a;
*		std::cin >> a;
*		
*		if (std::cin.fail()) {
*			std::cin.clear();
*			std::cin.ignore(32767, '\n');
*			std::cout << "Oops, that input is invalid. Please try again.\n";
*		}
*		else
*		{
*			std::cin.ignore(32767, '\n');
*			return a;
*		}
*	}
* }
*
*@.'std::cin.fail()' - проверка на предыдущее значение, переполнение
* @.'std::cin.ignore(32767, '\n')' - удаляем значения предыдущего ввода из входного буфера,
* до 32767 символов или '\n' ('\n' также удаляем)

#endif // Обработка некорректного пользовательского ввода

#ifdef Массивы

* @.'Массив' - совокупный тип данных, который позволяет получить доступ ко всем переменным одного и того же типа
*	данных, используя 'один идентификатор'
*
* 'Фиксированный массив'
* Пример
* int array[5] = { 4, 5, 8, 9, 12 };	// инициализация всех элементов
* int array[5] = { 5, 7, 9 };			// инициализируем первые 3 элемента
* int array[5] = { };					// инициализация всех элементов значением 0
* int array[5] { };						// С++11 uniform-инициализация
* int array[] = { 0, 1, 2, 3, 4 };		// список инициализаторов атоматически определит длину массива
*
* !.#'Совет:' Для фиксированного массива хорошим образом будет использовать константу 'compile-time'
*
* !.#'Совет:' Для лучшего представления элемента массива, лучше использовать enum (не enum class)
* Пример
* namespace StudentNames
* {
*	{
*		SMITH,			// 0
*		ANDREW,			// 1
*		IVAN,			// 2
*		JOHN,			// 3
*		ANTON,			// 4
*		MISHA,			// 5
*		MAX_STUDENTS	// 6
*	}
* }
* int main() {
*	int testScores[StudentNames::MAX_STUDENTS];	// всего 6 студентов
*	testScores[StudentNames::JOHN] = 65;		// инициализируем баллы John значением 65
* }
*
* !.'Важно:' C++ не копирует массив при его передаче в 'функцию'!
*	Передается фактический массив.
*
* 'Определение размера фиксированного массива'
* Пример
*	int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
*	std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";
*	Результат
*	the array has 8 elements
* sizeof(array) - размер массива
* sizeof(array[0]) - размер одного элемента массива
*
* @.'Сортировка массива' - это процесс распределения всех элементов массива в определенном порядке.
* 
* 'Многомерные массивы'
* Пример
* int array[][] = 
* {
*	{ 3, 4, 7, 8 },
*	{ 1, 2, 6, 9 }
* };
* int array[3][5] = { 0 };
* int array[3][2][1];
* int array[4][3][2][1];

#endif // Массивы

#ifdef Строки C-style и std::string

* @.'Нуль-терминатор' - это специальный символ '\0', для обозначения конца строки (ASCII-код '0').
* 
* @.'Строка C-style' - это массив символов, который использует нуль-терминатор.
* Пример
* char mystring[] = "string";
*	'string' - 6 букв
*	'\0' - нуль терминатор
*	итоговый размер строки 7! 's' 't' 'r' 'i' 'n' 'g' '\0' 
* 
* 'Имя не длиннее 255 символов'
*	char name[255];
*	std::cout << "Enter your name: ";
*	// cin.getline() будет принимать до 254 символа в массив name, оставляя место под '\0'
*	std::cin.getline(name, 255);
* 
* #include <cstring>
*	strcpy_s() - копировать содержимое одной строки в другую. (! переполнение)
*	strlen() - возвращает длину строки, без '\0'
*	strcat() - добавляет одну строку к другой (! переполнение)
*	strncat() - добавляет одну строку к другой
*	strcmp() - сравнивает две строки
*	strncmp() - сравнивает две строки до определенного количества символов
* 
* !.'Правило:' используйте std::string вместо строк C-style
* 
* 
* 'std::string'
* Класс проектирован таким образом, чтобы объекты могли быть изменяемыми, поэтому каждый
*	объект std::string хранит свою собственную 'копию' строки.
*	Это также справедливо и для константных строк const std::string
* 
* Для избегания копий придумали представление строки std::string_view (не используют '\0')
* Пример
* std::string_view text{ "hello" };		// представление для строки "hello"
* std::string_view str{ text };			// представление этой же строки
* Функции
* remove_prefix()	- удаляет символы из левой части представления
* remove_suffix()	- удаляет символы из правой части представления
* data()			- предоставить доступ к исходной строке
*						(необходим '\0' в исходной строке и чтобы она не была изменена)
* !.'Предупреждение:'
*	Следите за тем, чтобы исходная строка, на которую ссылается объект std::string_view,
*		не выходила за пределы области видимости и не изменялась до тех пор, пока используется
*		ссылающийся на нее объект std::string_view.

#endif // Строки C-style

#ifdef Указатели

* @.'Оператор адреса &' - позволяет узнать, какой адрес памяти присвоен определенной переменной.
* @.'Оператор разыменования *' - позволяет получить значение по указанному адресу
* 
* @.'Указатель' - это переменная, значением которой является адрес ячейки памяти.
*		Занимает 4Б / 8Б в зависимости от архитектуры.
* Пример
* int *ptr;
* Обязательно:
*	1. Тип укзателя должен соответствовать типу переменной, на которую он указывает
*	2. С++ не позволит напрямую присваивать адреса памяти указателю.
* Применение:
*	1. Массивы реализованы с помошью указателей.
*		Указатели могут использоваться для итерации по массиву.
*	2. Единственный способ дянамического выделения памяти в С++.
*	3. Для передачи большого количества данных в функцию без копирования этих данных.
*	4. Могут использоваться для передачи одной функции в качестве параметра другой функции.
*	5. Для достижения полиморфизма при работе с наследованием.
*	6. Могут использоваться для представления одной структуры/класса 
*		в другой структуре/классе, формируя, таким образом, целые цепочки.
* 
* #.'Совет:' Указывайте звездочку возле имени переменной.
*	Почему?
*	int* prt1, ptr2; 
*		ptr1 - указатель на значение типа int
*		ptr2 - обычная переменная типа int
*	int *ptr1, *ptr2; // правильно
* 
* 'Присвоение значения укзаателю'
* int value = 5;
* int *ptr = &value;
* 
* 
* @.'Нулевые указатели' - указатель, содержащий значение null
* Пример
*	int *ptr(0); 
* 
*	int *ptr;
*	ptr = 0;
* 
*	int *ptr(NULL);
* @.'nullptr' - ключесове слово, является константой r-value (C++11)
* Пример
* doAnything(0);		// компилятор определит как целочисленное значение
* doAnything(nullptr);	// точно нулевой указатель
* 
* #.'Совет:' Инициализируйте указатели нулевым значением, если не собираетесь присваивать им другие значения.
* #.'Совет:' В C++11 используйте nullptr для инициализации нулевых указателей.
* 
* @.'std::nullptr_t' - тип данных, который может иметь только одно значение - nullptr
*	Находится в библиотеке #include <cstddef>
* Применение:
*	Необходим для функций, которые в качестве аргумента принимают nullptr
* 
* 
* 'Указатели и массивы'
* При вычислении, фиксированный массив распадается в 'указатель на первый элемент' массива.
* Пример
* int array[4] = { 5, 8, 6, 4 };
* std::cout << *array; // выведется 5
* 
* Различия:
*	1. Основное различие возникает при использовании оператора sizeof
*	Фиксированный массив знает свою длину, а указатель на массив - нет.
*		int array[4] = { 5, 8, 6, 4 };
*		std::cout << sizeof(array) << '\n';		// выведется sizeof(int) * длина array
*		int *ptr = array;
*		std::cout << sizeof(ptr) << '\n';		// выведется размер указателя
*	2. Используя &; в двух случаях один и тот же адрес, но разная информация о типе. (вряд ли понадобится)
* 
* Поскольку фиксированный массив распадается в указатель, в качестве параметра
*	в функции будет именно указатель, и нам придется дополнительно передавать его размер.
* // Это тоже самое
* void printSize(int array[]);
* void printSize(int *array);
* #.'Совет:' Используйте синтаксис указателя (*) вместо синтаксиса массива ([]) при передаче
*				массивов в качестве параметров в функции.
* 
* 
* 'Указатель на указатель'
* Пример
* int **ptrptr;
* int ***ptrx3;
* int ****ptrx4;

#endif // Указатели

#ifdef Адресная арифметика

* Если ptr указывает на целое число, то
*	ptr + 1 является адресом следующего целочисленного значения
*	ptr - 1 адресом предыдущего целочисленного значения
* Элементы массива расположены в памяти последовательно, т.е.
*	размещены рядом (друг за другом)
* Пример
* int array[] = { 7, 8, 2, 4, 5 };
* std::cout << &array[0] << " " << &array[1] << ... << &array[4];
* std::cout << &array[0] << " " << &array[0] + 1 << ... << &array[0] + 4;
* Результат (тип int = 4Б)
* 0000005F2892F938 0000005F2892F93C 0000005F2892F940 0000005F2892F944 0000005F2892F948

#endif // Адресная арифметика

#ifdef Символьные константы C-style

* 'Рассмотрим выделение памяти:'
* 
* // Инициализация строки C-style
* char myName[] = "John";
* std::cout << myName[];
*	1. Выделяется память для фиксированного массива длиной 5 и 
*		инициализируется эта память строкой "John\0"
*	2. Поскольку память выделена для массива, можем изменять её содержимое.
*	3. Сам массив рассматривает как локальная переменная, поэтому,
*		при выходе из области видимости, уничтожается.
* // Инициализация строки C-style через указатели
*	1. Компилятор помещяет строку "John\0" в память тип read-only, 
*		затем создает указатель, который указывает на эту строку.
*		Поэтому следует перестраховаться и объявить как const char (хотя, иначе у меня ошибка компиляции)
*	2. Строка объявленная таким образом, имеет статическую продолжительность жизни
* const char *myName = "John";
* std::cout << myName;
* 
* 
* std::cout с типом char* и const char* предполагает, что нужно вывести 'строку'
*	Вместо вывода указателя - 'выведется строка'.

#endif // Символьные константы C-style

#ifdef Динамическое выделение памяти

* @.'Динамическое выделение памяти' - способ запроса памяти из ОС по мере необходимости.
*	Эта память берется из кучи (оператива)
* 
* @.'new' - это оператор, который возвращает указатель, содержащий адрес выделенной памяти.
* Пример
* int *ptr1 = new int(7);	// прямая инициализация
* int *ptr2 = new int{ 8 };	// uniform-инициализация
* 
* @.'delete' - это оператор, вовращающий память, которая была выделена раннее, обратно в ОС.
* Пример
* delete ptr;
* ptr = nullptr;
* 
* @.'Висячий указатель' - указатель, указывающий на освобожденную память.
* !.'Правило' - Присваивайте удаленным указателям значение nullptr
* 
* @.'std::nothrow' - константа, возвращает нулевой указатель new, если память не была выделена.
* Пример
* int *value = new (std::nothrow) int;
* if (!value) // Обрабатываем случай, когда не удалось выделить память.
* {
*	...
* }
* 
* @.'Утечка памяти' - когда программа теряет адрес некоторой динамически выделенной памяти,
*	прежде чем вернуть её обратно в ОС.
* Как?
*	1. Не позаботиться об очистке.
*	2. Локальная переменная вышла из области видимости.
*	3. Присвоить указателю другое значение.

#endif // Динамическое выделение памяти

#ifdef Указатели и const

* 'Указатели и const'
* @.'Указатель на костантную переменную' - указатель, не позволяет производить изменение
*	с переменной, на которую указывает.
* Пример
* const int *ptr = &value;
* 
* Обрабатывает переменную как константу
* Пример
* int value = 7;
* const int *ptr = &value;
* value = 8;	// ок
* *ptr = 9;		// нельзя
* 
* Можно менять адрес
* Пример
* int value1 = 7;
* const int *ptr = &value1;
* int value2 = 8;
* ptr = &value2;	// ок
* 
* 
* @.'Константный указатель' - указатель, значение которого не может быть изменено после инициализации.
*	Должен быть инициализирован при объявлении.
* Пример
* int *const ptr = &value;
* 
* Указывает всегда на один и тот же адрес
* int value1 = 7;
* int value2 = 8;
* int *const ptr = &value1;	// ок
* ptr = &value2;			// нельзя
* 
* Можно менять значение переменной
* int value = 7;
* int *const ptr = &value;
* *ptr = 8;		// ок
* 
* 
* @.'Константные указатели на константные значение' - указатель, который нельзя перенаправить, как и его
*	значение - нельзя изменить.
* int value = 7;
* const int *const ptr = &value;

#endif // Указатели и const

#ifdef Ссылки

* До этого мы рассмотрели 2 основных типа переменных:
*	1. Обычные переменные, хрянящие значения напрямую.
*	2. Указатели, которые хранят адрес другого значения, для доступа к которым выполняется операция *.
* Рассмотрим еще один тип:
* 
* @.'Ссылки'	- Тип переменной, который работает как псевдоним другого объекта или значения.
*				- Это указатель, который неявно разыменовывается при доступе к значению.
* С++ поддерживает 3 типа ссылок:
*	1. Ссылки на неконстантные значения.
*	2. Ссылки на константные значения.
*	3. Ссылки r-value (позже)
* Не могут быть нулевыми
* Применение:
*	1. В качестве параметра функции
*		// Поскольку это псевдоним, оно меняет значение переменной напрямую, без копирования!
*		void changeN(int &ref) {
*			ref = 8;
*		}
*	2. Сделать код более чистым и понятным.
*		struct Something
*		{
*			int value1;
*			float value2;
*		};
*		struct Other
*		{
*			Something something;
*			int otherValue;
*		};
*		Other other;
* 
*		int &ref = other.something.value1;
*		// следующее два стейтмента идентичны
*		other.something.value1 = 7;
*		ref = 7;
* 
* 'Ссылки vs указатели'
* int value = 7;
* int *const ptr = &value;
* int &ref = value;
*
* // следующие два стейтмента обрабатываются одинаково.
* *ptr = 7;
* ref = 7;
* 
* 
* 'На неконстантные значения'
* Могут быть инициализированы только 'неконстантными l-values'
* Пример
* int a = 7;
* int &ref1 = a;	// ок
* 
* const int b = 8;
* int &ref2 = b;	// нельзя: b - это const
* 
* int &ref3 = 4;	// нельзя: 4 - это r-value
* 
* int value1 = 7;
* int value2 = 8;
* int &ref = value1;
* ref = value2;		// value1 присваивается значение value2!
* 
* #.'Совет:' Передавайте аргументы в функцию через неконстантные ссылки-параметры, если они
*	должны быть изменены функцией в дальнейшем.
* 
* 
* 'На константные значения'
* Могут быть инициализированы l-values (в том числе const l-values) и const r-values
* Пример
* int a = 7;
* const int &ref1 = a;	// ок
*
* const int b = 8;
* const int &ref2 = b;	// ок
*
* const int &ref3 = 4;	// ок
* 
* r-values имеют область видимости выражения, что означает, что они 'уничтожаются в конце выражения',
*	в котором созданы.
* 
* #.'Совет:' Передавайте аргументы в функцию через константные ссылки-параметры, если они
*	не должны быть изменены функцией в дальнейшем.

#endif // Ссылки

#ifdef foreach

* @.'Цикл foreach' - цикл, предоставляющий простой и безопасный способ итерации.
*	Не работает с указателями! (должен знать размер)
* Применение:
*	Получение доступа ко всем элементам массива в последовательном порядке.
* Пример
* int array[7] = { 10, 8, 6, 5, 4, 3, 1 };
* for (const auto &element: array)
*	std::cout << element << ' ';

* !.'Правило': Используйте обычные ссылки или константные ссылки в качестве
*		объявляемого элемента в цикле foreach (в целях улучшения производительности).

#endif // foreach

#ifdef Введение в std::array

* (С++11)
* @.'std::array' - 'фиксированный' массив, который не распадает в указатель при его передаче в функцию.
*	Находится в #include <array>.
*	Обязательно указывать размер массива.
* Пример
* std::array<int, 4> myarray;
* std::array<int, 4> myarray = { 8, 6, 4, 1 };
* std::array<int, 4> myarray { 8, 6, 4, 1 };
* Функционал:
*	.at()		- доступ к члену с проверкой диапазона, бросит исключение out_of_range
*	size()		- узнать длину массива
* 
* 'Сортировка'
* #include <algorithm>
* ...
*	std::sort(myarray.begin(), myarray.end());		// по возрастанию
*	std::sort(myarray.rbegin(), myarray.rend());	// по убыванию

#endif // Введение в std::array

#ifdef Введение в std::vector

* (С++03)
* @.'std::vector' - динамический массив, который сам может управлять выделенной себе памятью.
*	Находится в #include <vector>
*	Нет утечек памяти. 
*	Самостоятельно определяет свою длину.
* Пример
* std::vector<int> array;
* std::vector<int> array2 = { 10, 8, 6, 4, 2, 1 };
* std::vector<int> array3 { 10, 8, 6, 4, 2, 1 };
* Функционал:
*	.at()		- доступ к члену с проверкой диапазона, бросит исключение out_of_range
*	.erase()	- удаление элемента (не допускать висячих итераторов)
*	size()		- узнать длину массива
*	resize()	- изменить длину массива (инициализируется по умолчанию в соответствии с типом данных: int - 0)
*		resize затратная операция, следует минимизировать подобные операции.

#endif // Введение в std::vector

#ifdef Введение в итераторы

* @.'Итератор' - это объект, разработанный специально для перебора элементов контейнера,
*		обеспечивающий во время перемещения по элементам доступ к каждому из них.
* Важно знать:
*	1. Начальную точку
*	2. Конечную точку
*	3. Оператор ++ для перемещения к следующему элементу
*	4. Оператор * для получения значения текущего элемента
* Пример ('указатель')
* std::array data{ 0, 1, 2, 3, 4, 5, 6 }; // (C++17)
* 
* auto begin{ &data[0] };
* auto end{ begin + std::size(data) };
* 
* for (auto ptr{ begin }; ptr != end; ++ptr)
* {
*	std::cout << *ptr << ' ';
* }
* 
* Тоже самое с применением итераторов из 'Стандартной библиотеки С++'
* std::array data{ 0, 1, 2, 3, 4, 5, 6 }; // (C++17)
* 
* auto begin{ data.begin() };	// auto begin{ std::begin(array) };	#include <iterator>
* auto end{ data.end() };		// auto end { std::end(array) };	#include <iterator>
* 
* for (auto ptr{ begin }; ptr != end; ++ptr)
* {
*	std::cout << *ptr << ' ';
* }

#endif // Введение в итераторы

#ifdef Алгоритмы в Стандартной библиотеке С++

* Функционал, предоставляемый библиотекой алгоритмов, обычно относится к одной из трех категорий:
* @.'Инспекторы'	- для просмотра данных в контейнере.
* @.'Мутаторы'		- для изменения данных в контейнере.
* @.'Фасилитаторы'	- для генерации результата на основе значений элементов данных.
* 
* #include <algorithm>
* std::find()		- поиск элемента по значению
* std::find_if()	- поиск элемента по значению с условием
* std::count()		- ищут количество вхождений элементов
* std::count_if()	- ищут количество вхождений элементов по условию
* std::sort()		- сортировка массива
* std::for_each()	- использовать одну и ту же операцию со всеми элементами
* 
* Параметры:
*	1. Итератор begin		
*	2. Итератор end		
*	3. Значение / функция, лямбда / тип данных
* 
* #include <functional>
* std::greater{}	// тип данных (пример std::sort в порядке убывания)
* 
* В С++20 добавили 'диапазоны', решающий гемор с begin() и end() TO DO
* Пример
* std::array data{ 0, 1, 2, 3, 4, 5, 6 };
* std::ranges::sort(data);
* for (auto const &i : data) 
*	std::cout << i << ' ';
* 
* #.'Совет' - Отдавайте предпочтения использованию функций из библиотеки алгоритмов, нежели изобретению велосипедов.
* 
* 
* 'std::find()' - поиск элемента по значению (возвращает end, в случае ненахождения)
* Пример
* std::array<int, 6> arr{ 13, 90, 99, 5, 40, 80 };
* int search{};
* int replace{};
* std::cin >> search >> replace;
* // ...проверка пользовательского ввода...
* auto found{ std::find(arr.begin(), arr.end(), search) };
* if (found == arr.end())
* {
*	std::cout << "Could not find " << search << '\n';
* }
* else 
* {
*	*found = replace;
* }
* 
* 
* 'std::find_if()' - поиск элемента с условием (возвращает end, в случае ненахождения)
* Пример
* // возвращает std::string_view::npos если не нашел подстроку, иначе - индекс, где нашел вхождение "nut"
* bool containsNut(std::string_view str) {
*	return (str.find("nut") != std::string_view::npos);
* }
* int main() {
*	std::array<std::string_view, 4> arr{ "apple", "banana", "walnut", "lemon" };
*	auto found{ std::find_if(arr.begin(), arr.end(), containsNut) }
*	if (found == arr.end())
*	{
*		std::cout << "No nuts\n";
*	}
*	else
*	{
*		std::cout << "Found " << *found << '\n';
*	};
* }
* 
* 
* 'std::sort()'	- сортировка массива, также добавили 3-й параметр, для пользовательской сортировки
* Пример
* bool greater(int a, int b) {
*	return (a > b)
* }
* int main {
*	std::array arr{ 13, 90, 99, 5, 40, 80 };
*	std::sort(arr.begin(), arr.end(), greater);	// или std::greater{} из #include <functional>
*	for (int i : arr)
*	{
*		std::cout << i << ' ';
*	}
* }
* 
* 
* 'std::for_each()'	- использовать одну и ту же операцию со всеми элементами
* Пример
* void doubleNumber(int &i) {
*	i *= 2;
* }
* int main() {
*	std::array arr{ 1, 2, 3, 4 };
*	std::for_each(arr.begin(), arr.end(), doubleNumber);
*	for (int i : arr)
*	{
*		std::cout << i << ' ';
*	}
* }

#endif // Алгоритмы в Стандартной библиотеке С++

#ifdef Параметры и аргументы функций

* #.'Интересно:' 
*		'Обработка параметров происходит справа-налево'
* void boo(int x, int y) {}
* boo(4, 5);
* При вызове boo() сначала создастся переменная 'y' и ей присвоится значение '5',
*	а затем уже создастся переменная 'x' и ей присвоится значение '4'
*	
* 
* @.'Передача по значению' - значение копируется в параметр функции.
* Пример
* void boo(int y) {
*	std::cout << "y = " << y << std::endl;
* }
*	'Плюсы'
*		1. Аргументы, переданные по значению, 'могут быть почти всем', чем угодно.
*			(переменными, литералами, выражениями, структурами, классами или перечислителями и тд.)
*		2. 'Аргументы никогда не изменяются' функцией, в которую передаются,
*			что предотвращает возникновение побочных эффектов.
*	'Минусы'
*		1. Копирование структур и классов может привести к значительному снижению производительности
*			(особенно, при частом вызове)
* 
*	'Применение'
*		- При передаче фундаментальных типов данных и перечислителей, когда предполагается, 
*			что функция 'не должна изменять аргумент'.
*	'Не надо'
*		- При передаче массивов, структур и классов.
* 
* 
* @.'Передача по ссылке' - ссылка на переменную обрабатывается точно так же, как и сама переменная.
* Пример
* void boo(int &y) {
*	std::cout << "y = " << y << std::endl;
* }
*	'Плюсы'
*		1. Ссылки 'позволяют' функции 'изменять значение аргумента', что иногда полезно.
*			В противном случае, для гарантии того, что функция не изменит значение аргумента,
*			нужно использовать 'константные ссылки'
*		2. Гораздо эффективнее и быстрее передачи по значению, особенно при работе с большими
*			структурами и классами
*		3. Ссылки могут использоваться для возврата сразу нескольких значений из функции
*	'Минусы'
*		1. Трудно определить, является ли параметр, переданный по неконстантной ссылке,
*			параметром ввода, вывода или того и другого одновременно.
*			Разумное использование const и суффикса Out для внешних переменных решает эту проблему.
*		2. По вызову функции невозможно определить, будет аргумент изменен функцией или нет.
*			Аргумент, переданный по значению или по ссылке, выглядит одинаково. Мы можем определить
*			способ передачи аргумента 'только просмотрев объявление функции'. Это может привести к
*			ситуации, когда 'программист не сразу поймет', что функция изменяет значение аргумента
* 
*	'Применение'
*		- При передаче структур или классов
*		- Когда нужно, чтобы функция изменяла значения аргумента
*	'Не надо'
*		- При передаче фундаментальных типов данных (используйте передачу по значению)
*		- При передаче обычных массивов (используйте передачу по адресу)
* 
* 
* @.'Передача по адресу' - это передача адреса переменной-аргумента
*	Пример
*	void boo(int *y) {
*		std::cout << "y = " << y << std::endl;
*	}
*	'Плюсы'
*		1. Передача по адресу позволяет функции изменить значения аргумента, что иногда полезно.
*			В противном случае, для гарантии того, что функция не изменит значение аргумента,
*			нужно использовать const
*		2. Поскольку копирования аргументов не происходит, то скорость передачи по адресу достаточно
*			высокая, даже если передавать большие структуры или классы.
*		3. Можем вернуть сразу несколько значений из функции, используя параметры вывода.
*	'Минусы'
*		1. Все указатели 'нужно проверять', не являются ли они нулевыми.
*			Попытка разыменовать нулевой указатель приведет к сбою в программе.
*		2. Посколько 'разыменование указателя выполняется медленее', чем доступ к значению напрямую,
*			то доступ к аргументам, переданным по адресу, выполняется также медленее, чем доступ к
*			аргументам, переданным по значению.
* 
*	'Применение'
*		- При передаче обычных массивов 
*			(если нет проблем, с тем, что массивы распадаются в указатели при передаче)
*	'Не надо'
*		- При передаче структур или классов (используйте передачу по ссылке)
*		- При передаче фундаментальных типов данных (используйте передачу по значению)
* 
* 
* !.'Правило:' Используйте передачу 'по ссылке', вместо передачи 'по адресу', когла это возможно.

#endif // !Параметры и аргументы функций

#ifdef Возврат значений функции

* @.'Возврат по значению'
* Пример
* int doubleValue(int a) {
*	int value = a * 3;
*	return value;
* }
*	'Применение'
*		- Возврат переменных, которые были объявлены внутри функции
*		- Возврат аргументов функции, которые были переданы в функцию по значению
*	'Не надо'
*		- При возврате стандартных массивов или указателей
*			(используйте возврат по адресу)
*		- При возврате больших структур или классов
*			(используйте вовзрат по ссылке)
* 
* 
* @.'Возврат по адресу'
* Пример
* int* doubleValue(int a) {
*	int value = a * 3;
*	return &value;
* }	// !висячий указатель
* Пример получше
* int* allocateArray(int size) {
*	return new int[size];
* }
*	'Применение'
*		- При возврате динамически выделенной памяти
*		- При возврате аргументов функции, которые были переданы по адресу
*	'Не надо'
*		- При возврате переменных, которые были объявлены внутри функции
*			(используйте возврат по значению)
*		- При возврате большой структуры или класса, который был передан по ссылке
*			(используйте вовзрат по ссылке)
* 
* 
* @.'Возврат по ссылке'
* Пример
* int& doubleValue(int a) {
*	int value = a * 3;
*	return value;
* } // !ссылка на мусор
* Пример получше
* int& getElement(std::array<int, 20> &array, int index) {
*	return array[index];
* }
*	'Применение'
*		- При возврате ссылки-параметра
*		- При возврате элемента массива, который был передан в функцию
*		- При возврате большой структуры или класса, который не уничтожается в конце функции
*	'Не надо'
*		- При возврате переменных, которые были объявлены внутри функции
*			(используйте возврат по значению)
*		- При возврате стандартного массива или значения указателя
*			(используйте возврат по адресу)

#endif // !Возврат значений функции

#ifdef Встроенные функции

* @.'inline' - ключевое слово, используется для запроса, чтобы компилятор рассматривал
*		функцию как встроенную.
* Пример
* inline int max(int a, int b) { return a < b ? b : a; }
* int main() {
*	std::cout << max(7, 8) << '\n';
*	std::cout << max(5, 4) << '\n';
* }
* Программа вызывает дважды функцию max(),
*  но с ключевым словом inline, ЦП будет читать код следующим образом:
* int main() {
*	std::cout << (7 < 8 ? 8 : 7) << '\n';
*	std::cout << (5 < 4 ? 4 : 5) << '\n';
* }
* 
* #.'Интересно:'
*		Современные компиляторы автоматически пометят функцию как встроенную, если та посчитает,
*			что это способствует улучшению производительности.
* 
* !.'Правило:' Если вы используете современный компилятор, то нет необходимости использовать
*		ключевое слово inline.
* 
* #.'Интересно:'
*		Встроенные функции освобождаются от "правила одного определения"

#endif // Встроенные функции

#ifdef Перегрузка функций

* @.'Перегрузка функций' - возможность определять несколько функций с одним и тем же именем,
*		но с разными параметрами.
* Пример
* int subtract(int a, int b) { return a - b; }
* int subtract(int a, int b, int c) { return a - b - c; }
*	Тип возврата функции НЕ учитывается при перегрузке функции!
* 
* 'Шаги при компиляции'
*	1. Найти точное совпадение.
*	2. Если точного совпадения не найдено, то С++ пытается найти совпадение путем дальнейшего
*		неявного преобразования типов:
*			char, unsigned char и short -> int
*			unsigned short				-> int или unsigned int
*			float						-> double
*			enum						-> int
*	3. Если неявное преобразование невозможно, то С++ пытается найти соответствие посредством 
*		стандартного преобразования.
*			Любой числовой тип соответствует другому числовому типу, включа unsigned
*				(Например int = float)
*			enum соответствует формальному типу числового типа данных
*				(Например enum = float)
*			Ноль соответствует типу указателя и числовому типу
*				(Например 0 как char* или 0 как float)
*			Указатель соответствует указателю типа void
*	4. С++ пытается найти соответствие путем пользовательского преобразования.
*			Классы могут определять преобразования в другие типы данных, которые
*				могут быть неявно применены к объктам этих классов.

#endif // Перегрузка функций

#ifdef Параметры по умолчанию

* @.'Параметр по умолчанию' - Параметр функции, который имеет определенное (по умолчанию) значение.
* Пример
* void printValues(int a, int b=5) { 
*	std::cout 
*		<< "a: " << a << '\n' 
*		<< "b: " << b << '\n'; 
* }
* int main() {
*	printValues(1);		// a: 1		b: 5
*	printValues(6, 7);	// a: 6		b: 7
* }
* Или
* void printValues(int a=10, int b=11, int c=12)
* 
* !.'Правило:' Все параметры по умолчанию в прототипе или в определении функции должны находиться справа.
* void printValue(int a=5, int b); // не разрешается
* void printValue(int a, int b=5); // правильно
* 
* !.'Правило:' Если имеется более одного параметра по умолчанию, то 'самым левым параметром' должен быть
*		тот, который с 'наибольшой вероятностью будет явно переопределен' пользователем.
* 
* Можно перегрузить НО
*	таким образом нельзя
* void printValues(int a);
* void printValues(int a, int b=15);

#endif // Параметры по умолчанию

#ifdef Указатели на функции

* @.'Указатель на функцию'
*	'У указателя' на функцию и самой функции 'должны совпадать'
*		тип, параметры и тип возвращаемого значения.
* Пример
* // fcnPtr - это указатель на функцию, которая не принимает никаких аргументов
* //	и возвращает целочисленное значение
* int (*fcnPtr)();
* // Создание константного указателя на функцию
* int (*const fcnPtr)();
* 
* Распространненая ошибка новичков:
*	fcnPtr = doo(); 
* Присваиваем возвраащемое значение из вызова функции doo() указателю fcnPtr.
* 
* 
* 'Вызов функции через указатель на функцию'
* Способы:
*	1. Через явное разыменование
*	Пример
*		int boo(int a) {
*			return a;
*		}
*		int main() {
*			int (*fcnPtr)(int) = boo;
*			(*fcnPtr)(7);
*		}
*	2. Через неявное разыменование
*	Пример
*		int boo(int a) {
*			return a;
*		}
*		int main() {
*			int (*fcnPtr)(int) = boo;
*			fcnPtr(7);
*		}
*		Способ неявного разыменования выглядит так же, как и вызов обычной функции,
*			т.к. обычные имена функции = указателю на функцию
* 
* #.'Примечание:' 
*	Параметры по умолчанию не будут работать с функциями, вызванными через указатели на функции.
*		Параметры по умолчанию обрабатываются 'во время компиляции'
*		Указатели на функции обрабатываются 'во время выполнения'
* 
* 
* 'Передача укзаателя на функцию в параметр функции'
* Пример
* bool ascending(int a, int b) {
*	return a > b;
* }
* void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int)) {
*	...
* }
* Еще пример, с параметром по умолчанию в функции-параметре
* // Если пользователь вызовет selectionSort без параметра функции, то по умолчанию фунция будет соответствовать ascending
* void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int) = ascending) {
*	...
* }
* 
* 
* 'Синтаксис уродлив!'
* Применяем typedef
* Пример
* // определили псевдоним validateFcn
* typedef bool (*validateFcn)(int, int);
*	// bool validate(int a, int b, bool (*fcnPtr)(int, int));
*	bool validate(int a, int b, validateFcn pfcn);
* 
* Применяем type alias (C++11)
* using validateFcn = bool(*)(int, int);
*	bool validate(int a, int b, validateFcn pfcn);
* 
* Применяем std::function (C++11) из #include <functional>
*	bool validate(int a, int b, std::function<bool(int, int)> fcn);
*		или
*	using validateFcn = std::function<bool(int, int)>;
*	bool validate(int a, int b, validateFcn);

#endif // Указатели на функции

#ifdef Стек и Куча

* Память, которую использует программа, состоит из нескольких частей - сегментов:
*	1. 'Сегмент кода', где находится скомпилированная программа
*	2. 'Сегмент bss', где хранятся глобальные и статические переменные, инициализированные нулем
*	3. 'Сегмент данных', где хранятся инициализированные глобальные и статические переменные
*	4. 'Куча', откуда выделяются динамические переменные
*	5. 'Стек вызовов', где хранятся параметры функции, локальные переменные и другая информация,
*			связанная с функциями.
* 
* @.'Куча' - Отслеживает память, используемую для динамического выделения.
* Пример
*	При помощи оператора new
* int *ptr = new int;
* Особенности:
*	Выделение памяти в куче сравнительно медленное.
*	Выделенная память остается выделенной до тех пор, пока не будет освобождена (остерегайтесь утечек)
*		или пока программа не завершит свое выполнение
*	Доступ к динамически выделенной памяти осуществляется только через указатель.
*		Разыменование указателя происходит медленнее, чем доступ к переменной напрямую.
*	Поскольку куча представляет собой большой резервуар памяти, то именно она используется
*		для выделения больших массивов, структур или классов.
* 
* 
* 'Стек' - Отслеживает все активные функции от начала программы и до текущей точки выполнения,
*	и обрабатывает выделение всех параметров функции и локальных переменных.
* 
* @.'Стек' - Структура данных типа LIFO (Last In, Fisrt Out)
* @.'Фрейм стека' - Элементы стека, которые мы добавляем / вытягиваем
* @.'Указатель стека' - Отслеживает вершину стека
* @.'Переполнение стека' - В ОС на стек ограниченная память, для Windows ~ 1 МБ
* 
* Особенности:
*	Выделение памяти в стеке быстрее.
*	Память, выделенная в стеке, остается в области видимости до тех пор, пока находится в стеке
*	Вся память, выделенная в стеке, обрабатывается во время компиляции
*	Не рекомендуется делать что либо, что сьест много памяти
* 
* Стек вызывов на практике:
*	Программа сталкивается с вызовом функции
*	Создается фрейм стека, который помещается в стек, он состоит из:
*		адреса инструкции, который находится ЗА вызовом функции (обратный адрес).
*		аргументов функции
*		памяти для локальных переменных
*		сохраненных копий всех регистров, модифицированных функцие, которые необходимо будет
*			восстановить после того, как функция завершит свое выполнение.
*	Процессор переходит к точке начала выполнения функции.
*	Выполняются инструкции внутри функции
* 
* После завершения функции:
*	Регистры восстанавливаются из стека вызовов
*	Фрейм стека вытягивается из стека. Освобождается память, которая была выделена
*		для всех локальных переменных и аргументов
*	Обрабатывается возвращаемое значение
*	ЦП возобновляет выполнение кода (исходя из обратного адреса)
* 
* Некоторые архитектуры считают возвращаемое значение частью стека, другие используют
*	регистры процессораю
* 
*	top() / peek()	- посмотреть верхний элемент стека
*	pop()			- вытянуть верхний элемент стека
*	push()			- добавить новый элемент поверх стека

#endif // Стек и Куча

#ifdef Ёмкость вектора

* 'Длина' в std::vector - это количество фактически используемых элементов
* 'Ёмкость' в std::vector - это количество выделенных элементов
*	может быть больше длины
* Т.к. изменение размера затратная операция, то при изменении длины в меньшую
*	сторону ёмкость останется прежней, также ёмкость может выделиться компилятором с запасом.
* 
* push_back()	- Добавляет элемент в стек
* back()		- Вовзращает значение верхнего элемента стека
* pop_back()	- Вытягивает элемент из стека
* reserve()	- Заранее выделить объем ёмкости

#endif // Ёмкость вектора

#ifdef Рекурсия и Числа Фибоначчи

* @.'Рекурсивная функция' - функция, которая вызывает сама себя.
* Пример 
* void countOut(int count) {
*	std::cout << "push " << count << '\n';
*	if (count > 1) // условие завершения
*		countOut(count-1);
*	std::cout << "pop " << count << '\n';
* }
* int main() {
*	countOut(4);
* }
* 
* 
* 'Рекурсия vs Итерация'
* Итеративные функции, почти всегда более эффективны, чем рекурсивные аналоги.
* Однако, иногда рекурсивная реализация может быть чище и проще:
*	дополнительные расходы могут быть оправданы сведя к минимуму трудности при будущей поддержке кода.
* 
* Выбрать рекурсию, если выполняется большинство из следующих утверждений:
*	Рекурсивный код намного проще реализовать
*	Глубина рекурсии может быть ограничена
*	Итеративная версия алгоритма требует управления стеком данных
*	Это не критическая часть кода, которая напрямую влияет на производительность программы

#endif // Рекурсия и Числа Фибоначчи

#ifdef Обработка ошибок

* @.'std::cerr' - это объект вывода, выводит сообщение об ошибках в консоль,
*	но эти сообщения можно еще и перенаправить в отдельный файл с ошибками.
* Пример
* std::cerr << "Error while opening the file " << filename << std::endl;
* 
* 
* @.'assert' - срабатывает во время выполнения программы
* Пример
* assert(found && "Animal could not be found in database");
* 
* @.'static_assert' - срабатывает во время компиляции
* Пример
* static_assert(sizeof(long) == 8, "long must be 8 bytes");
* 
* В С++11, сообщение об ошибке обязательно
* В С++17, сообщение об ошибке можно опустить
* Отключить assert (для релизного кода)
*	// #define NDEBUG

#endif // Обработка ошибок

#ifdef Аргументы командной строки 

* @.'Аргументы командной строки' - это необязательные строковые аргументы, передаваемые ОС 
*		в программу при ее запуске
* 'Обозреватель Решений' -> 'Свойства'
*		'Отладка' -> 'Аргументы команды'
* 
* int main(int argc, char *argv[])
*	'argc' - количество аргументов
*	'argv' - значения аргументов // можно char **argv

#endif // Аргументы командной строки 

#ifdef Эллипсис

* @.'Эллипсис' - последний параметр функции, пишется как ...
*	О нем можно думать, как о массиве, который содержит любые другие параметры.
*	#include <cstdarg>
*	Макросы:
*		va_list list;			- Объявление списка
*		va_start(list, count);	- Инициализация списка (count - последний параметр, не являющимся эллипсисом)
*		va_arg(list, int);		- Получение параметров из запроса (int - ожидаемый тип)
*		va_end(list);			- Очистка списка
* Пример
* double findAverage(int count, ...) {
*	double sum = 0;
*
*	va_list list;
*	va_start(list, count);
*	for (int arg{}; arg < count; ++arg)
*		sum += va_arg(list, int);
*	va_end(list);
*
*	return sum / count;
* }
* int main() {
*	std::cout << findAverage(4, 1, 2, 3, 4) << '\n';
*	std::cout << findAverage(5, 1, 2, 3, 4, 5) << '\n';
* }
* 
* Недостаток:
*	Компилятор не производит проверку типов.
*	std::cout << findAverage(5, "Hello world!", 2, 3, 4, 5) << '\n'; // скомпилируется
* Используем декодер, чтобы сообщить, как правильно интерпретировать параметры:
* Пример
* double findAverage(std::string decoder, ...) {
*	double sum = 0;
*
*	va_list list;
*	va_start(list, decoder);
*	int count = 0;
*	while (1)
*	{
*		char codetype = decoder[count];
*		switch (codetype)
*		{
*		default:
*		case '\0':
*			va_end(list);
*			return sum / count;
*		case 'i':
*			sum += va_arg(list, int);
*			count++;
*			break;
*		case 'd':
*			sum += va_arg(list, double);
*			count++;
*			break;
*		}
*	}
* }
* int main() {
* 	std::cout << findAverage("iiii", 1, 2, 3, 4) << '\n';
* }

#endif // Эллипсис

#ifdef Лямбда

* @.'Лямбда-выражения' - позволяет определить анонимную функцию внутри другой функции.
* Пример
* []() {};
* Еще пример
* auto isEven {
*	[](int i) {
*		return ((i % 2) == 0);
*	}
* };
* 
* #.'Интересно:' Лямбды являются особым типом объектов, которые называются функторами
*
* @.'Функтор' - Объект, содержащие перегруженный operator (), который и делате их вызываемыми,
*		подобно обычным функциям.
* 
* 
* Пример объявления внутри функции
* int main() {
*	// Обычный указатель на функцию. Лямбда не может ничего захватить
*	double (*addNumbers1)(double, double) {
*		[](double a, double b) {
*			return a + b;
*		}
*	};
*	std::cout << addNumbers1(1, 2) << '\n';
*	
*	// Используем std::function. Ляибда может захватывать переменные
*	std::function addNumbers2{
*		[](double a, double b) {
*			return a + b;
*		}
*	};
*	std::cout << addNumbers1(3, 4) << '\n';
*
*	// Используем auto. Храним лямбду с её реальным типом.
*	auto addNumbers3{
*		[](double a, double b) {
*			return a + b;
*		}
*	};
*	std::cout << addNumbers1(5, 6) << '\n';
* }
* 
* !.'Правило' - Используйте auto при инициализации переменных с помощью лямбд
*				Используйте std::function, если вы не можете инициализировать переменную с помощью лямбд.
* 
* #.'Интересно:' - Для каждого отдельного типа, выводимого с помощью auto, 
*		будет сгенерированна отдельная Лямбда.
* 
* 
* @.'Лямбда-захваты' - Позволяют использовать (клонировать?) переменные находящиеся не в теле Лямбды.
* #.'Интересно:' - Когда компилятор обнаруживает определение лямбды, он создает для нее определение
*		как для пользовательского объекта. Каждая захваченная переменная становится элементом этого объекта.
*		Во время выполнения программы, при обнаружении определении Лямбды, создается экземпляр объекта лямбды и 
*		в этот момент инициализируются члены лямбды.
* По умолчанию переменные захватываются как const
* 
* 
* 'Захват по значению'
* Пример
* int ammo{ 10 };
* auto shoot{
*	[ammo]() {
*		--ammo;	// ошибка компиляции
*		std::cout << "Pew! " << '\n';
*	}
* };
* Чтобы производить изменения, может пометить лямбду как mutable
* auto shoot{
*	[ammo]() mutable {
*		--ammo;
*		std::cout << "Pew! " << '\n';
*	}
* };		
* 
* 'Захват по ссылке'
* Пример
* auto shoot{
*	[&ammo]() {
*		--ammo;	// ошибка компиляции
*		std::cout << "Pew! " << '\n';
*	}
* };
* 
* 
* 'Захват всех задействованных переменных'
*	[=] - по значению
*	[&] - по ссылке
* Пример
* auto shoot{
*	[&]() {
*		--ammo;	// ошибка компиляции
*		std::cout << "Pew! " << '\n';
*	}
* };
* Еще пример
*	[=, &enemies](){};	// enemies по ссылке, остальные по значению
*	[&, armor](){};		// armor по значению, остальные по ссылке
* 
*	[&, &armor](){};				// нельзя (уже ссылка)
*	[=, armor](){};					// нельзя (уже по значению)
*	[armor, &health, &armor](){};	// нельзя (armor используется дважды)
*	[armor, &](){};					// нельзя (& или = должен стоять первым)
* 
* #.'Совет:' Инициализируйте переменные в захвате только в том случае, если их значения 
*		не являются слишком большими и их тип очевиден. В противном случае, лучше всего
*		определить переменную вне лямбды, а затем захватить её.
* 
* 
* !.'Правило:' Если вы хотите использовать лямбду вместе с изменяемыми захваченными переменными,
*		то передавайте их по ссылке с помощью std::ref
* Пример
* void invoke(const std::function<void(void)> &fn) { 
*	fn ();
* }
* int main() {
*	int i{};
*	// Выполняем инкримент и выводим на экран локальную копию переменной i
*	auto count{ [i]() mutable {
*		std::cout << ++i << '\n';
*	} };
* 
*	invoke(std::ref(count));
*	invoke(std::ref(count));
*	invoke(std::ref(count));
* }

#endif // Лямбда

#ifdef Введение в ООП

* Объекты имеют два основных компонента:
*	Свойства (вес, цвет, прочность, размер)
*	Поведение (открывать что-то, делать что-то)
* 
* @.'ООП' - стилистика написания кода главным образом через объекты, имеющие свои свойства и поведение;
*		а ни через процессы и функции (процедурное программирование)
* Пример
* class DateClass
* {
* public:
*	int m_day;
*	int m_month;
*	int m_year;
* };
* 
* Как и со структурами, объявление класса 'не приводит к веделению памяти'.
* 
* #.'Интересно:' Класс, которому выделена память, освободит её непосредственно перед моментом уничтожения класса.
*			Предполагать то же самое при работе со структурами - небезопасно.
* !.'Правило:'	Рекомендуется использовать struct для структур, используемых только для 'хранения данных'.
*			и class для определения объектов, которые требуют объединения как 'данных, так и функций'.
* 
* @.'Метод' - то же самое, что функция, но пренадлежит объекту.
* 
* @.'Спецификатор public' - доступ к членам можно осуществлять 'извне и внутри'.
* @.'Спецификатор private' - доступ к членам можно осуществлять только 'внутри'.
* @.'Спецификатор protected' - доступ к членам можно осуществлять внутри и извне для дружественных и дочерних классов.
* 
* Структура vs Классы
*	Спецификатор	
*					у struct по умолчанию public:
*					у class по умолчанию private:
*	Наследуют от других конструкций
*					struct открыто
*					class закрыто

#endif // Введение в ООП

#ifdef Инкапсуляция

* @.'Инкапсуляция' - процесс скрытого хранения деталей реализации объекта.
*		Пользователи обращаются к объекту через открытый интерфейс.
* Преимущества:
*	1. Проще в использовании и уменьшают сложность программ.
*	2. Помогают защитить данные и предотвращают их неправильное использование.
*	3. Легче изменить.
*	4. Легче проводить отладку
* 
* @.'Функция доступа' - короткая открытая функция, задачей которой является получение или
*		изменение значения закрытой пременной-члена класса.
* // геттер
*	int getDay() { return m_day; }
* // сеттер
*	void setDat(int dat) { m_day = day; }
* 
* !.'Правило:' Предоставляйте функции доступа только в том случае, когда нужно,	
*		чтобы пользователь имел возможность получать/присваивать значения членам класса.
* 
* !.'Правило:' Геттеры должны использовать тип возврата 'по значению' или 'по константной ссылке'.

#endif // Инкапсуляция

#ifdef Конструкторы

* @.'Конструктор' - Особый тип метода, который автоматически вызывается 'при создании' объекта.
*	! Всегда должны иметь то же имя, что и класс
*	! Не имеют типа возврата (даже void)
*	! Не может быть const
*	! Не может быть static
* @.'Конструктор по умолчанию' - Конструктор, не имеющий параметров
* @.'Неявно генерируемый конструктор' - Если класс не имеет конструкторов, 
*		сгенерируется автоматически ClassName(){}
* Пример
* class Date
* {
* private:
*	int m_day = 12;
*	int m_month = 1;
*	int m_year = 2018;
* public:
*	Date(int day, int month, int year)
*	{
*		m_day = day;
*		m_month = month;
*		m_year = year;
*	}
*	// неявный конструктор не создастся, так как мы уже определили свой.
* };
* 
* int main() {
*	Date date; // ошибка, конструктор по умолчанию отсутствует
*	Date today(14, 10, 2020); // Ок
* }
* 
* !.'Правило:' Создавайте хотя бы один конструктор, даже если это пустой конструктор по умолчанию.
* 
* 
* Инициализация более эфективна чем присваивание после объявления.
* 'Используем список инициализации:'
*	! Не инициализируйте переменные-члены таким образом, чтобы они зависели от других
*		переменных-членов, которые инициализируются первыми.
*	! Инициализируйте переменные в списке инициализации в том порядке, в котором они объявлены в классе
* Пример
* Values() : m_value1(3), m_value2(4.5), m_value3('d')
* {
*	// Нет необходимости использовать присваивание
* }
* Пример с передачей значения
* Values(int value1, double value2, char value3 = 'd')
*	: m_value(value1), m_value2(value2), m_value3(value3)
* {
*	// Нет необходимости использовать присваивание
* }
* Пример напрямую с параметрами по умолчанию
* Values() : m_value(7)
* {
* }
* !.'Правило:' Используйте uniform-инициализацию вместо прямой инициализации в С++
* Values() : m_value{ 7 }
* {
* }
* 
* !.'Правило:' Используйте списки инициализации членов, вместо операций присваивания,
*		для инициализации переменных-членов вашего класса.
* 
* 
* @.'Делегирующий конструктор' - Конструктор, вызывающий другой конструктор.
*	! Запрещается инициализация членов класса
*	! Необходимо следить за вызовами, предотвращая бесконечный цикл
* Пример (С++11)
* Boo()
* {
*	// Часть кода X
* }
* 
* Boo(int value)
* {
*	Boo(); // Используем, для выполнения кода X
*	// Часть кода Y
* }
* 
* Или
* Boo(int value): Boo() // Используем, для выполнения кода X
* {
*	Часть кода Y
* }
* 
* До С++11 скомпилируется, но приведет к созданию временного объекта, который затем инициализируется
*	с помощью конструктора этого объекта и отбрасывается, оставляя исходный объект неизменным.
* 
* Бывают ситуации, когда нужно написать метод для повторной инициализации класса 'обратно до значений по умолчанию.'
*	Может быть соблазн снова вызвать конструктор - приведет к неожиданным результатам.
*	Лучше 'переместить код в новый метод' и заставить конструктор вызывать этот метод.
* Пример
* private:
*	void DoX()
*	{
*		// Часть кода X
*	}
* public:
*	Boo()
*	{
*		DoX();
*	}
*	Boo(int value)
*	{
*		DoX();
*		// Часть кода Y
*	}
* 

#endif // Конструкторы

#ifdef Деструкторы

* @.'Деструктор' - метод класса, который выполняется при удалении объекта класса.
*	! Должен иметь то же имя, что и класс, со знаком тильда ~
*	! Не может принимать аргументы
*	! Не имеет тип возврата
*	! Только один деструктор на класс
* Пример
* class Massiv
* {
*	/// code
* public:
*	Massiv(int length)
*	{
*		assert(length > 0);
*		m_array = new (std::nothrow) int[length];
*		m_length = length;
*	}
*	~Massiv()
*	{
*		delete[] m_array;
*	}
*	/// code
* }
* 
* @.'Идиома RAII' (получение ресурсов есть инициализация) - идиома ООП, при которой
*	использование ресурсов привызывается к времени жизни объектов с автоматической 
*	продолжительностью жизни. 
*	В С++ реализуется через классы с конструкторами и деструкторами.
*	! В рамках идиомы ресурсы объекты не должны быть динамически выделенными, 
*		поскольку тут уже пользователь несет ответственность за их уничтожение,
*		а деструктор вызывается после уничтожения объекта.
* 
* Предупреждение о exit(): если используете, программа завершится и деструкторы не будут вызваны.
*	Если полагаетесь на свои деструкторы - имейте в виду.

#endif // Деструкторы

#ifdef Скрытый указатель *this

* @.'this'
* 'При вызове метода класса, как С++ отслеживает то, какой объект его вызвал?'
* Ответ
* С++ для этих целей использует скрытый указатель *this!
*	! Является константным указателем - вы можете изменить значение исходного объекта,
*		но вы не можете заставить указатель указывать на что-то другое! 
* Пример
* class Another
* {
* private:
* 	int m_number;
* 
* public:
* 	Another(int number)
* 	{
* 		setNumber(number);
* 	}
* 
* 	void setNumber(int number) { m_number = number; }
* 	int getNumber() { return m_number; }
* };
* 
* int main() {
* 	Another another(3);
* 	another.setNumber(4);
* 	std::cout << another.getNumber() << '\n';
* }
* 
* Подробно:
*	1. При вызове another.setNumber(4) компилятор фактически
*		вызывает setNumber(&another, 4)
*	2. Внутри setNumber() указатель *this содержит адрес объекта another
*	3. К любым переменным-членам внутри setNumber() добавляется префикс this->
*		Поэтому m_number = number компилятор фактически
*		выполняет this->m_number = number;
* 
* 
* *this всегда указывает на текущий объект
*	Another X(3); // *this = &X внутри конструктора Another
*	Another Y(4); // *this = &Y внутри конструктора Another
*	X.setNumber(5); // *this = &X внутри метода setNumber
*	Y.setNumber(6); // *this = &Y внутри метода setNumber
* 
* 
* 'Применение:'
* 'Устранить неоднозначность'
* Пример
* class Something
* {
*	// всё равно предпочтительнее именовать с префиксом m_
*	int data;
* public:
*	Something(int data)
*	{
*		this->data = data;
*	}
* };
* 
* 
* 'Свазать несколько вызовов (цепочка)' 
*	(часто используют при перегрузке операторов)
* class Mathem
* {
*	int m_value;
* public:
*	Mathem() { m_value = 0; }
*	
*	Mathem& add(int value) { m_value += value; return *this; }
*	Mathem& sub(int value) { m_value -= value; return *this; }
*	Mathem& multiply(int value) { m_value *= value; return *this; }
* 
*	int getValue() { return m_value; }
* };
* 
* int main() {
*	Mathem operation;
*	operation.add(7).sub(5).multiply(3);
* 
*	std::cout << operation.getValue() << '\n';
* }

#endif // Скрытый указатель *this

#ifdef Классы и заголовочные файлы .h .cpp

* Отделить объявление от реализации поможет оператор разрешения области видимости ::
* Во многих случаях, функции доступа могут состоять из одной строки кода, тогда их обычно оставляют в теле класса.
* Пример
* class Mathem
* {
*	int m_value = 0;
* 
* public:
*	Mathem(int value = 0);
* 
*	Mathem& add(int value);
*	Mathem& sub(int value);
*	Mathem& devide(int value);
* 
*	int getValue() { return m_value; }
* };
* 
* Mathem::Mathem(int value): m_value(value)
* {
* }
* 
* Mathem& Mathem::add(int value) {
*	m_value += value;
*	return *this;
* }
* 
* Mathem& Mathem::sub(int value) {
*	m_value -= value;
*	return *this;
* }
* 
* Mathem& Mathem::divide(int value) {
*	m_value /= value;
*	return *this;
* }
* 
* #.'Важно:'
* Разве определение 'класса' в заголовочном файле не нарушает правило одного определения?
*	Нет. Классы - пользовательские типы данных, которые освобождаются от определения только в одном месте.
*	Поэтому класс, определенный в заголовочном файле, можно свободно подключать в другие файлы.
* 
* Разве определения 'методов класса' в заголовочном файле не нарушает правило одного определения?
*	Методы, определенные внутри тела класса, считаются неявно встроенными.
*	Встроенные функции освобождаются от правила одного определения.
*	Методы, определенные вне тела класса, рассматриваются, как обычные функции, и подчиняются
*		правилу одного определения (должны быть определены в .cpp и .h)
* 
* Параметры по умолчанию для методов должны быть объявлены в .h
* 
* Классы, используемые в нескольких файлах или предназначенные для повторного использования, определять в .h
* Тривиальные методы (конструкторы, деструкторы, функции доступа) определять в .h
* 
* Классы, используемые только в одном файле, которые не используются повторно определять в .cpp
* Нетревиальные методы в .cpp

#endif // Классы и заголовочные файлы .h .cpp

#ifdef Классы и const

* Объекты классов можно сделать константными
*	! Инициализация выполняется через 'конструкторы' классов.
* Пример
* const Date date1;					// инициализация через конструктор по умолчанию
* const Date date2(12, 11, 2018);	// инициализация через конструктор с параметрами
* const Date date3{ 12, 11, 2018 }; // инициализация через конструктор с параметрами в C++11
* 
*	! Могут явно вызывать только константные методы класса.
* Пример
* @.'Константный метод' - метод, который гарантирует, что не будет изменять 
*		объект или вызывать некостантные методы класса
* int getValue() const { return m_value; }
* 
* !.'Правило:' Делайте все методы, которые не изменяют данные объекта класса - const.
* 
* Можно перегрузить:
*	const std::string& getValue() const { return m_value; } // getValue() для const объектов
*	std::string& getValue() { return m_value; } // getvalue() для не-const объектов

#endif // Классы и const

#ifdef Классы и static

* @.'Статические переменные-члены' - являются общими для всех объектов класса.
*	! Существуют, даже если объекты класса не созданы.
*		Доступ осуществляется напрямую через имя класса и ::
*	! Если класс определен в .h, то static в .cpp, 
*		если определен в .cpp, то static также в .cpp под классом
* Пример
* class Anything
* {
* public:
*	static int s_value;
* };
* 
* int Anything::s_value = 3; // определяем статическую переменную-член (если не инициализировали, то = 0)
* 
* int main() {
*	Anything first;
*	Anything second;
* 
*	first.s_value = 4;
* 
*	std::cout << first.s_value << '\n';
*	std::cout << seconds.s_value << '\n';
* }
* // Вывод: 4 4
* 
* 
* Можно инициализировать и в теле класса, 
*	если является интегральным типом (int, char, bool и тп.) или const enum
*	и для любых типов, поддерживающие constexpr (C++11)
* Пример
* class Anything
* {
* public:
*	static const int f_value = 5;
*	static constexpr double s_value = 3.4; 
*	static constexpr std::array<int, 3> s_array = { 3, 4, 5 };
* 
* 
* 'Применение:'
*	'Для уникального идентификатора'
* Пример
* class Anything
* {
*	static int s_idGenerator;
*	int m_id;
* public:
*	Anything() { m_id = s_idGenerator++; }
*	int getID() const { return m_id; }
* };
* 
*	'Когда классу необходимо использовать внутреннюю таблицу поиска'
* // Не создавать копии таблицы, для всех объектов её использующих.
* 
* 
* @.'Статические методы класса' - Позволяет получить доступ к статической переменной объекта
*		не создавая объект.
*	! Существуют, даже если объекты класса не созданы.
*		Доступ осуществляется напрямую через имя класса и ::
*	! Не имеют указателя *this => не могут обращаться к нестатическим членам
* Пример
* class Anything
* {
* private:
*	static int s_value;
* public:
*	static int getValue() { return s_value; } // статический метод
* };
* 
* 
* 'Определяя вне тела класса, не пишем' static!
* Пример
* class IDGenerator
* {
*	static int s_nextID;
* public:
*	static int getNextID();
* }
* 
* int IDGenerator::s_nextID = 1;
* int IDGenerator::getNextID() { return s_nextID++; }

#endif // Классы и static

#ifdef Классы и friend

* @.'Дружественная функция' - функция, которая имеет доступ к закрытым членам класса, как если бы она сама
*		была членом этого класса. Во всех других отношениях - является обычной функцией.
*	! Используется ключевое слово friend перед прототипом функции.
*	! Не имеет указателя *this
*	! Может быть дружественной сразу для нескольких классов
* Пример
* class Something
* {
*	int m_value;
* public:
*	Something(int value) { m_value = value; }
*	friend bool isEqual(const Something &value1, const Something &value2);
* };
* 
* bool isEqual(const Something &value1, const Something &value2) { 
*	return (value1.m_value == value2.m_value);
* }
* 
* 
* @.'Дружественные классы' - подобно функциям, классы тоже могут дружить.
*	Это значит, что класс '2' получит доступ к классу '1'.
*	! не имеют прямой доступ к *this
*	! если '1' друг '2', это не означает, что '2' друг '1'
* Может нарушить принцип инкапсуляции (осторожно)
* Пример
* class Values
* {
*	int m_intValue;
*	double m_dValue;
* public:
*	Values(int intValue, double dValue) 
*	{
*		m_intValue = intValue;
*		m_dValue = dValue;
*	}
* 
*	// Класс Display теперь друг класса Values
*	friend class Display;
* };
* 
* class Display
* {
*	bool m_displayIntFirst;
* public:
*	// Display имеет доступ к private-членам Values
*	Display(bool displayIntFirst) { m_displayIntFirst = displayIntFirst; }
*	void displayItem(Values &value) {
*		(m_displayIntFirst) ?
*			std::cout << value.m_intValue << " " << value.m_dValue << '\n' :
*			std::cout << value.m_dValue << " " << value.m_intValue << '\n';
*	}
* 
* int main() {
*	Values value(7, 8.4);
*	Display display(false);
*	display.displayItem(value);
* }
* 
* 
* @.'Дружественные методы' - Чтобы не делать дружественным целый класс.
*	! Объявление аналогично обычной friend, но с префиксом имяКласса::
*	! Компилятору необходимо увидеть определение класса, с которым хотим дружить.
*		(лучше разбить на .h .cpp)
* Пример 
* class Values; // предварительное объявление класса Values
* class Display {
*	// определение класса Display
* }
* class Values 
* {
*	// см. код выше
*	// Делаем метод Display::displayItem() другом класса Values
*	friend void Display::displayItem(Values& value);
* }
* 
* void Display::displayItem(Values &value) {
*	/// code
* }

#endif //  Классы и friend

#ifdef Анонимные объекты

* @.'Анонимный объект' - Объект без имени.
*	! Являются r-values (
*		область выражения
*		передача по значению / константной ссылке
*		используются один раз
*	)
* 'В возвращающем значении'
* Пример
* int add(int a, int b) { return a + b }
* 
* 'В параметре функции'
* Пример
* printResult(int value) { std::cout << value; }
* int main() {
*	printResult(4 + 2);
* }
* 
* При вычислении выражения a + b / 4 + 2, результат помещается в анонимный объект.
* Затем копия анонимного передается куда нужно и уничтожается.
* 
* 'Анонимные объекты класса'
* Пример
* class Dollars
* {
*	int m_dollars;
* public:
*	Dollars(int dollars) { m_dollars = dollars; }
*	int getDollars() const { return m_dollars; }
* };
* 
* void print(const Dollars &dollars) {
*	std::cout << dollars.getDollars() << " dollars.";
* }
* 
* int main() {
*	print(Dollars(7)); // передаем анонимный объект класса Dollars
* }
* 
* Применение:
*Для передачи или возврата значений, без необходимости создавать временные переменные.

#endif // Анонимные объекты

#ifdef Измерение времени выполнения (тайминг) кода

*	! Используйте режим конфигурации "Release"
*	! Выполняйте тайминг минимум 3 раза
*	! Не запускайте ничего лишнего в фоном режиме при прогонах кода
*	! Не допускайте рандома
*	
* Инкапсулируем необходимый функционал библиотеки chrono в класс
* #include <chrono>
* class Timer
* {
* private: 
*	using clock_t = std::chrono::high_resolution_clock;
*	using second_t = std::chrono::duration<double, std::ratio<1> >;
* 
* 	std::chrono::time_point<clock_t> m_beg;
*
* public:
* 	Timer() : m_beg(clock_t::now())
* 	{
* 	}
* 
* 	void reset() {
* 		m_beg = clock_t::now();
* 	}
* 
* 	double elapsed() const {
* 		return std::chrono::duration_cast<second_t>(clock_t::now() - m_beg).count();
* 	}
* };
*
* int main() {
*	std::array<int, g_arrayElements> array;
*	for (int i = 0; i < g_arrayElements; ++i)
*		array[i] = g_arrayElements - i;
* 
*	Timer t;
*	std::sort(array.begin(), array.end());
*	std::cout << "Time taken: " << t.elapsed() << '\n';
* }

#endif // Измерение времени выполнения (тайминг) кода

#ifdef Перегрузка операторов

*	! Почти любой оператор может быть перегружен, кроме: 
*		?:	sizeof	 ::	 .	 .*
*	! Можете перегрузить только существующие операторы.
*	! По крайней мере один из операндов перегруженного оператора должен быть
*		'пользовательского типа' данных.
*	! Изначальное количество операндов, поддерживаемых оператором, изменить невозможно.
*	! Все операторы сохраняют свой 'приоритет и ассоциативность' по умолчанию.
*
* !.'Правило:' При перегрузке операторов старайтесь максимально приближенно сохранять функционал
*		операторов в соответствии с их первоначальными применениями.
* 
* 'Вызов перегруженных операторов'
* Действия компилятора:
*	1. Если все операнды являются фундаментальных типов данных, то вызывать следует
*		встроенные соответствующие версии операторов (если таковые существуют).
*		Если таких не существует, то компилятор выдаст ошибку.
*	2. Если какой-либо из операндов является пользовательского типа данных, то компилятор
*		ищет версию оператора, которая работает с таким типом данных. Если компилятор не найдет
*		подходящего, то попытается выполнить конвертацию одного или нескольких операндов
*		пользовательского типа данных в фундаментальные типы данных, чтобы таким образом он мог
*		использовать соотвествующий встроенный оператор. Если это не сработает - комплитор 
*		выдаст ошибку.
* 
* 
* @.'Перегрузка операторов через дружественные функции'
*	Для перегрузки бинарных операторов, которые не изменяют левый операнд
*	+ Имеем прямой доступ ко всем членам класса, с которым работаем.
*	! Ограничения, не может быть:	=	[]	()	->	(уже через методы класса - требования языка С++)
* Пример operator+
* class Dollars
* {
*	int m_dollars;
* public:
*	Dollars(int dollars) { m_dollars = dollars; }
*	// Dollars + Dollars через дружественную функцию
*	friend Dollars operator+(const Dollars &d1, const Dollars &d2);
*	int getDollars() const { return m_dollars; }
* };
* 
* Dollars operator+(const Dollars &d1, const Dollars &d2) {
*	return Dollars(d1.m_dollars + d2.m_dollars);
* }
* 
* 
* @.'Перегрузка операторов через обычные функции'
*	Для перегрузки бинарных операторов, которые не изменяют левый операнд
*	Когда не нужен доступ к членам определенного класса (геттеры)
* Пример operator+
* class Dollars
* {
*	int m_dollars;
* public:
*	Dollars(int dollars) { m_dollars = dollars; }
*	int getDollars() const { return m_dollars; }
* };
* 
* Dollars operator+(const Dollars &d1, const Dollars &d2) {
*	return Dollars(d1.getDollars() + d2.getDollars());
* }
* 
* !.'Правило:' Используйте перегрузку операторов через обычные функции, вместо дружественных,
*		если для этого не требуется добавлнение дополнительных функций в класс.
* 
* 
* @.'Перегрузка операторов через методы класса'
*	При работе с 'бинарными операторами', которые 'изменяют ЛЕВЫЙ операнд' 
*		и с 'унарными операторами'.
*	Также =	[]	()	->
*	Похожа на дружественные функции, НО
*		левым операндом становится неявный объект, на который указывает *this
*	(не нужно писать две версии: Dollars + int / int + Dollars)
* Пример operator+
* class Dollars
* {
*	int m_dollars;
* public:
*	Dollars(int dollars) { m_dollars = dollars; }
*	// Dollars + int
*	Dollars operator+(int value);
*	int getDollars() const { return m_dollars; }
* };
* 
* Dollars Dollars::operator+(int value) {
*	return Dollars(m_dollars + value);
* }
* 
* 
* 'Перегрузка операторов ввода и вывода'
* Пример operator<< 
* (через дружественную)
* class Point
* {
*	double m_x, m_y, m_z;
* public:
*	Point(double x = 0.0, double y = 0.0, double z = 0.0)
*		: m_x(x), m_y(y), m_z(z)
*	{
*	}
*	friend std::ostream& operator<< (std::ostream &out, const Point &point);
* };
* 
* // Я вижу здесь аналогию с *this
* std::ostream& operator<< (std::ostream &out, const Point &point) {
*	out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ')';
*	return out;
* }
* 
* Пример operator>> 
* (через дружественную)
* class Point
* {
*	double m_x, m_y, m_z;
* public:
*	Point(double x = 0.0, double y = 0.0, double z = 0.0)
*		: m_x(x), m_y(y), m_z(z)
*	{
*	}
*	friend std::ostream& operator>> (std::istream &in, Point &point);
* };
* 
* std::ostream& operator>> (std::istream &in, Point &point) {
*	in >> point.m_x;
*	in >> point.m_y;
*	in >> point.m_z;
*	return in;
* }
* 
* 
* 'Перегрузка унарных операторов +, - и логического НЕ'
* (через метод)
* Пример operator-
* class Dollars
* {
*	int m_dollars;
* public:
*	Dollars(int dollars) { m_dollars = dollars; }
*	// -Dollars
*	Dollars operator-() const;
*	int getDollars() const { return m_dollars; }
* };
* 
* Dollars dollars::operator-() const {
*	return Dollars(-m_dollars);
* }
* 
* 
* 'Перегрузка операторов сравнения'
* (через дружественную)
* Пример operator==
* class Car
* {
*	std::string m_company;
*	std::string m_model;
* public:
*	Car(std::string company, std::string model)
*		: m_company(company), m_model(model)
*	{
*	}
*	
*	friend bool operator== (const Car &c1, const Car &c2);
* };
* 
* bool operator== (const Car &c1, const Car &c2) {
*	return (c1.m_company == c2.m_company &&
*			c1.m_model == c2.m_model);
* }
* 
* 
* 'Перегрузка операторов инкремента и декремента'
* (через метод)
* Пример operator++
*	! Для версии постфикс С++ использует 'фиктивный параметр', лишь для одной цели:
*		отличить префикс и постфикс версии.
* class Number
* {
*	int m_number;
* public:
*	Number(int number = 0)
*		: m_number(number)
*	{
*	}
*	Number& operator++(); // префикс
*	Number& operator++(int); // постфикс
* };
* 
* Number& Number::operator++() {
*	if (m_number == 8) m_number = 0;
*	else ++m_number;
*	return *this;
* }
* 
* Number& Number::operator++(int) {
*	Number temp(m_number);
*	// Используем оператор инкремента 'префикс', для реализации перегрузки инкремента 'постфикс'
*	++(*this);
*	return temp;
* }
* 
* 
* 'Перегрузка оператора индексации []'
*	! Возврат по ссылке
*	! Не используйте указатель на объекты
* (через метод)
* Пример
* class IntArray
* {
*	int m_array[10];
* public:
*	int& operator[] (const int index);			// присваивание и просмотр
*	const int& operator[] (const int index);	// только для просмотра
* };
* 
* int& IntArray::operator[] (const int index) {
*	return m_array[index]
* }
* const int& IntArray::operator[] (const int index) {
*	return m_array[index]
* }
* 
*	Почему по ссылке?
*	IntArray array;
*	array[4] = 5;
*	//
*	[] выше приоритет чем =
*	1. компилятор: array[4].array[4] - вызов функции перегрузки оператора []
*	2. возврат: array.m_array[4], поскольку по ссылке - вернет фактический элемент array.m_array[4]
*	3. обработанное: array.m_array[4] = 5
*	m_array[4] - l-values (имеет адрес памяти) => проблем нет.
*	Если по значению:
*	2. Если m_array[4] является 7, то фактически получаем 7.array[4] = 5
*	7 = 5 - бессмыслица!
* 
*	//
*	Указатель на объекты:
*	IntArray *array = new IntArray;
*	array[4] = 5 // ошибка, указатель = адрес памяти, а ни значение.
*	(*array)[4] = 5 // правильно, но ужасно
* 
* 
* 'Перегрузка оператора ()'
*	! Может изменять несколько параметров
*	! В случае с классами перегрузка круглых скобок выполняется в operator()(){}
*	! Как правило, используются для доступа к двумерным массивам или возврата подмножеств одномерного массива.
* (через метод)
* Пример
* class Matrix
* {
*	double data[5][5];
* public:
*	double& operator()(int row, int col);
*	const double& operator()(int row, int col) const;
*	void operator()();
* };
* 
* double& Matrix::operator()(int row, int col) {
*	assert(col >= 0 && col < 5);
*	assert(row >= 0 && row < 5);
*	return data[row][col];
* }
* const double& Matrix::operator()(int row, int col) const {
*	assert(col >= 0 && col < 5);
*	assert(row >= 0 && row < 5);
*	return data[row][col];
* }
* void Matrix::operator()() {
*	for (int row=0; row < 5; ++row)
*		for (int col=0; col < 5; ++col)
*			data[row][col] = 0.0;
* }
* 
* 
* 'Перегрузка функтора'
*	! Работают как функции
*	! Могут хранить данные в переменных-членах
* (через метод)
* Пример
* class Accumulator
* {
*	int m_counter = 0;
* public:
*	int operator() (int i) { return (m_counter += i); }
* };
* 
* 
* 'Перегрузка операции преобразования значений'
*	! Внимание на пробел между operator и int()
*	! Не имеет типа возврата (предполагается, что возвращаете корректный тип)
* (через метод)
* Пример
* class Dollars {
*	int m_dollars;
* public:
*	operator int() { return m_dollars; }
* };
* Еще пример
* class Cents {
*	int m_cents;
* public:
*	operator Dollars() { return Dollars(m_cents / 100); }
* };
* 
* 
* 'Перегрузка оператора присваивания'
* 'Присваивание vs Конструктор копирования'
*	! Оба копируют значение одного объекта в другой, однако
*		Конструктор копирования - инициализация новых объектов
*		Оператор присваивания - заменяет содержимое уже существующих объектов
*	! Осуществите проверку на самоприсваивание
*	! По умолчанию 'почленное копирование'
*		В работе с динамической памятью следует писать свою реализацию.
* Пример
* class Drob {
*	int m_numerator;
*	int m_denominator;
* public:
*	Drob& operator= (const Drob &drob) {
*		// проверка на самоприсваивание
*		if (this == &drob)
*			return *this;
*		
*		// Выполняем копирование значений
*		m_numerator = drob.m_numerator;
*		m_denominator = drob.m_denominator;
* 
*		// Возвращаем текущий объект
*		return *this;
*	}

#endif // Перегрузка операторов

#ifdef Конструктор копирования

* @.'Конструктор копирования' - особый тип конструктора, который используется для создания нового
*		объекта через копирование существующего объекта.
*	! Можно предотвратить копирования, поместив его в private
*	! Может игнорироваться компилятором
*	! По умолчанию 'почленная инициализация'
*		В работе с динамической памятью следует писать свою реализацию.
* Пример
* class drob {
*	int m_numerator;
*	int m_denominator;
* public:
*	// Конструктор по умолчанию
*	Drob(int numerator = 0, int denominator = -1) :
*		m_numerator(numerator), m_denominator(denominator)
*	{
*		assert(denominator != 0);
*	}
*	// Конструктор копирования
*	Drob(const Drob &drob) :
*		m_numerator(drob.m_numerator), m_denominator(drob.m_denominator)
*	{
*		std::cout << "Copy constructor\n";
*	}
* };
* 
* 'Игнорирование компилятором'
* // Используя класс выше, вызываем
*	Drob sixSeven(Drob(6, 7));
* Пытаемся:
*	1. Инициализировать анонимный объект Drob => вызов конструктора Drob(int, int)
*	2. Использовать конструктор копирования с анонимным объектом для инициализации sixSeven
* Результат:
*	Поскольку результат точно такой же, как при прямой инициализации,
*		компилятор проигнорирует копирование.
*		(Это называется @.'Элизия')
*	Drob sixSeven(6, 7); // изменено компилятором, прямая инициализация
* 
* 
* 'Копирующая инициализация'
* Пытаемся:
*	Drob seven = Drob(7);
* Реальный вызов:
*	Drob seven(Drob(7)); // Обработка компилятора
*		? вызывается конструктор по умолчанию Drob(int; int)
*		? вызывается конструктор копирования Drob(const Drob&)
* 
* Передаем по значению:
* // В этом случае все ок
* Drob makeNegative(Drob d) {
*	d.setNumerator(-d.getNumerator());
*	return d;
* }
* int main() {
*	Drob sixSeven(6, 7);
*	std::cout << makeNegative(sixSeven);
* }
* // Но также может игнорироваться
* class Something {};
* Something boo() {
*	Something x;
*	return x;
* }
* int main() {
*	Something x = boo();
* }
* 
* !.'Правило:' Избегайте использования копирующей инициализации при работе с классами,
*		вместо нее используйте uniform-инициализацию.
* 
* 
* @.'Конструкторы преобразования' - конструкторы которые используются в неявных преобразованиях
* @.'explicit' - ключевое слово, делает конструктор закрытым для выполнения 
*		любых неявных преобразований
* Пример
* class SomeString {
*	std::string m_string;
* public:
*	explicit SomeString(int a) { 
*		m_string.resize(a);
*	}
*	SomeString(const char *string) {
*		m_string = string;
*	}
* };
* 
* Также для предотвращения использования метода/перегруженных операторов можем использовать delete.
* Пример
* public:
*	SomeString(char) = delete; // любое использование этого конструктора приведет к ошибке
* 
* !.'Правило:' Для предотвращения возникновения ошибок с неявными конвертациями делайте ваши
*		конструкторы явными, используя ключевое слово explicit

#endif // Конструктор копирования

#ifdef Типы связей между объектами

* @.'Композиция' - 'Часть чего-то' (Часть-целого)
*	Когда двигатель не существует отдельно от автомобиля.
*	Он создается при создании автомобиля и полностью управляется автомобилем.
* 
* @.'Агрегация' - 'Имеет' (Части могут существовать отдельно)
*	Экземпляр двигателя создается где-то в другом месте кода,
*	и передается в конструктор автомобиля в качестве параметра.
* 
* 
* @.'Ассоциация' - 'Использует' (Объекты не связаны и могут принадлежать одновременно нескольким объектам)
*	Врач связан с пациентом, но эти отношения не назвать "части целого"
* 
* @.'Рефлексивная ассоциация' - 'Включает' (Объекты могут иметь отношения с другими объектами того же типа)
*	Между университетским курсом и его минимальными требованиями для студентов
* 
* 
* @.'Зависимость' - Как ассоциация, но однонаправленная.
*	Классы используют std::cout для вывода чего-то в консоль, но не наоборот

#endif // Типы связей между объектами

#ifdef Контейнерные классы

* @.'Контейнерный класс' - класс, предназначенный для хранения и огранизации нескольких
*		объектов определенного типа данных.
*	! Не позволяет смешивать разные типы данных внутри одного контейнера.
* Пример std::array, std::vector
*	
* Функционал классов-контейнеров языка С++:
*	Создание пустого контейнера (через конструктор)
*	Добавление нового объекта в контейнер
*	Удаление объекта из контейнера
*	Просмотр количества объектов, находящихся на данный момент в контейнере
*	Очистка контейнера от всех объектов
*	Доступ к сохраненным объектам
*	Сортировка объектов/элементов (не всегда)

#endif // Контейнерные классы

#ifdef Список инициализации std::initializer_list

*	! Обязательно указать тип std::initializer_list<int>
*	! size() возвращает количество элементов списка
*	! Проследить, чтобы хотя бы одно из действий было выполнено:
*		Перегрузка операторов присваивания
*		Корректное глубокое копирование для оператора присваивания
*		Наличие явного конструктора (с ключевым словом explicit), чтобы он не мог
*			использоваться для неявных преобразований
* 
* Пример
* // Позволяем инициализацию ArrayInt через список инициализации
* ArrayInt(const std::initializer_list<int> &list):
*	// Используем концепцию делегирования конструкторов
*	ArrayInt(list.size())
* {
*	// Инициализация начального массива значениями из списка инициализации
*	int count = 0;
*	for (auto &el : list) {
*		m_data[count] = el;
*		++count;
*	}
* }
* 
* Когда C++11 видит список инициализации, то он автоматически конвертирует его
*	в объект типа std::initializer_list.
* Поэтому, если мы создадим 'конструктор', который принимает в качестве параметра
*	std::initializer_list, мы сможем создавать объекты, 'используя список инициализации'
*	в качестве входных данных.
*	#include <initializer_list>

#endif // Список инициализации std::initializer_list

#ifdef Введение в Наследование

* @.'Иерархия' - Диаграмма со связями объектов.
*	Демонстрируют прогресс с течением времени
*	Классофицируют вещи таким образом, чтобы они переходили от общего к конкретному
* 
* Класс, от которого наследуют, называют 'родительским'
* Класс, который наследует, называется 'дочерним'
* 
* 
* @.'Наследование' - Механизм, посредством которого один класс может наследовать свойства другого.
* Child воспринимать как класс, имеющий в себе Parent и Child
*	(сначала вызывается конструктор Parent, затем вызывается конструктор Child)
* 
*	! По умолчанию закрытое наследование (private)
*	! Спецификатор доступа protected (доступ дружественным и дочерним классам)
*	! Объявляйте деструктор virtual
*	! Модификатор final, помогает блокировать дальнейшее наследование
* 
* 'Открытое наследование'
*	class Pub: public Parent
*		// - public-члены остаются public в дочернем классе;
*		// - protected-члены остаются protected в дочернем классе;
*		// - private-члены остаются недоступными в дочернем классе;
* 'Закрытое наследование'
*	class Pri: private Parent
*		// - public-члены становятся private в дочернем классе;
*		// - protected-члены становятся private в дочернем классе;
*		// - private-члены остаются недоступными в дочернем классе;
* 'Защищенное наследование'
*	class Pro: protected Parent
*		// - public-члены становятся private в дочернем классе;
*		// - protected-члены остаются protected в дочернем классе;
*		// - private-члены остаются недоступными в дочернем классе;
* 
* 
* 'Как инициализировать значения родителю?'
*	- Используя его конструктор
* class Child: public Parent
* {
* private:
*	double m_value;
* public:
*	Child(double value = 0.0, int id = 0)
*		: Parent(id), m_value(value)
*	{
*	}
* }
* 
* 'Как переопределить метод родителю?'
*	- Объявить идентичный метод в теле класса
*	(Сначала идет поиск в текущем классе, если не нашлось, то
*		используем метод из родительского)
* 
* 'Как использовать метод родителя?'
*	- Используя оператор разрешения области видимости ::
* class Child : public Parent
* {
* public:
*	void identify() {
*		Parent::identify();
*		std::cout << "I am a Child!\n";
*	}
* };
* 
* 'Как скрыть родительский метод в дочернем классе?'
*	- Использовать using-объявление в нужном спецификаторе доступа
*	- Или может сделать метод недоступным, при помощи delete
* class Parent
* {
* public: 
*	int m_value;
* };
* class Child
* {
* private:
*	using Parent::m_value;
* }
*
* // После темы с Виртуальными функциями
* 'Модификатор final'
* class A 
* {};
* class B final : public A	// всё ок
* {};
* class C : public B		// ошибка компиляции: нельзя наследовать final-класс
* {};
*
* !.'Правило:' При работе с наследованием ваши деструкторы должны быть 'виртуальными'.

#endif // Введение в Наследование

#ifdef Указатели, Ссылки и Наследование

* Child child(7);
* 
* Child &rChild = child;	// ссылка
* Child *pChild = &child;	// указатель 
* 
* 'Можем ли указать на родителя Child?'
* - Можем
* Parent &rParent = child;
* Parent *pParent = &child;
* 
* Применение (для перехода в тему virtual):
*	1. Parent использует данные Child
*		Вместо перегрузки каждого метода, можно использовать указатель/ссылку на Parent
*		// проблема, что вызовется Animal::speak()
*		void report(Animal &rAnimal) {
*			std::cout << rAnimal.getName() << " says " << rAnimal.speak() << '\n';
*		}
*	2. Хотим сохранить все Child в массиве (а в массиве объекты одного типа)!
*		Dog barsik("Barsik"), tolik("Tolik"), tyzik("Tyzik");
*		Cat matros("Matros"), ivan("Ivan"), martun("Martun");
*		Animal *animals[] = { &matros, &ivan, &martun, &barsik, &tolik, &tyzik};
*		// проблема, что вызовется Animal::speak() остаётся, для этого переходим в 'Виртуальные функции'

#endif // Указатели, Ссылки и Наследование

#ifdef Виртуальные функции и Полиморфизм

* @.'Виртуальная функция' - Особый тип функции, которая, при её вызове, 
*		выполняет наиболее дочерний метод.
*	! После написания virtual в Parent, по умолчанию также проставится в Child.
*	! Типы должны совпадать
*	! Нельзя вызывать виртуальные функции в теле конструкторов/деструкторов
*	! Занимает больше времени, чем обычный метод
*	! Модификатор override поможет бросить исключение, если типы не совпадают 
*	! Модификатор final запрещает дальнейшее переопределение
*		(Также можно запретить наследование класса)
* Пример
* class Parent {
* public:
*	virtual const char* getName() { return "Parent"; }
* };
* class Child {
* public:
*	virtual const char* getName() { return "Child"; }
* };
* int main() {
*	Child child;
*	Parent &rParent = child;
*	// вызов Child::getName()
*	std::cout << rParent.getName() << '\n'; 
* }
* 
* 'Игнорирование виртуальных функций'
* - Возможно, при помощи разрешения области видимости ::
* Пример
* Child child;
* Parent &parent = child;
* std::cout << parent.Parent::getName() << std::endl;
* 
* !.'Правило:' Никогда не вызывайте виртуальные функции в теле конструкторов или деструкторов.
* !.'Правило:' Используйте модификатор override для каждого из своих переопределений.
* 
* Пример с модификатором override
* // Parent
* virtual const char* getName1(int x) { return "A"; }
* virtual const char* getName2(int x) { return "A"; }
* virtual const char* getName3(int x) { return "A"; }
* // Child
* virtual const char* getName1(short int x) override { return "B"; } // ошибка компиляции
* virtual const char* getName2(int x) const override { return "B"; } // ошибка компиляции
* virtual const char* getName3(int x) override { return "B"; }		 // все ок
* 
* Пример с final
* // Parent
* virtual const char* getName() { return "A"; }
* // Child
* virtual const char* getName() override final { return "B"; }	// всё ок
* // GrandChild
* virtual const char* getName() override { return "C"; }		// ошибка компиляции, в Child - final
* 
* 
* @.'Ковариантный тип возврата' - если тип возврата ссылка/указатель, то
*		переопределения могут возвращать ссылку/указатель на собственный класс.
* Пример
* class Parent {
* public:
*	virtual Parent* getThis() { std::cout << "Parent::getThis()\n"; return this; }
*	void printType() { std::cout << "returned a Parent\n"; }
* };
* class Child {
* public:
*	virtual Child* getThis() { std::cout << "Child::getThis()\n"; return this; }
*	void printType() { std::cout << "returned a Child\n"; }
* };
* int main() {
*	Child ch;
*	Parent *p = &ch;
*	ch.getThis()->printType(); // вызов Child::getThis() возвращает Child*
*	p->getThis()->printType(); // вызов Child::getThis() возвращает Parent*
* }

#endif // Виртуальные функции и Полиморфизм

#ifdef Раннее и Позднее Связывания

* 'При компиляции:'
* Компилятор конвертирует каждый стейтмент программы в одну или несколько
*	строк машинного кода. Каждой строке машинного кода присваивается собственный
*	уникальный адрес.
* Так же и с функциями: когда компилятор встречает функцию, она конвертируется в
*	машинный код и получает свой адрес.
* 
* @.'Связывание' - процесс, который используется для 'конвертации идентификаторов в адреса'
* 
* 
* 'Раннее связывание'
*	+ Эффективнее, процессор может перейти к адресу функции.
* Когда компилятор/линкер встречает вызов функции, он заменяет его инструкцией
*	машинного кода, которая сообщает процессору перейти к адресу функции.
* 
* @.'Прямой вызов функции' - стейтмент, который напрямую вызывает функцию.
* Пример
* printValue(7); // выполняется с помощью раннего связывания
* 
* 
* 'Позднее связывание'
*	- Менее эффективнее, тк присутствует посредник между процессором и функцией.
* В некоторых программах невозможно знать наперёд, какая функция будет вызываться первой.
* Для позднего связывания используются указатели на функции.
* 
* @.'Непрямой вызов функции' - вызов функции через указатель на функцию.
* Пример
* int (*pFcn)(int, int) = add;	// создаем указатель
* int op;
* cin >> op;
* switch (op) 
* {
* case 0: pFcn = add;		break;
* case 1: pFcn = subtract;	break;
* case 2: pFcn = multiply;	break;
* }
* std::cout << pFcn(4, 5);		// позднее связывание

#endif // Раннее и Позднее Связывания

#ifdef Виртуальные таблицы

* @.'Виртуальная таблица' - таблица поиска функция для выполнения вызовов функций в 
*		режиме позднего связывания.
*	Это обычный статический массив, который создается компилятором во время компиляции
*	
*	! Любой класс, использующий виртуальные функции имеет собственную виртуальную таблицу.
*	  Таблица содержит по одной записи на каждую виртуальную функцию, которая может быть
*		вызвана объектами класса.
*	! Компилятор добавляет скрытый указатель на родителкий класс 
*	  (назовем его __vptr)
* 
* 
* *this фактически является параметром функции, используемым компилятором для
*		указания на самого себя.
* __vptr является реальным указателем на виртуальную таблицу класса,
*		размер каждого объекта увеличивается на размер этого указателя.
*		Также наследуется дочерними классами.
* 
* Пример (подробно)
* // *__vptr с двумя записями function1 и function2
* //	function1 указывает на Parent::function1()
* //	function2 указывает на Parent::function2()
* class Parent {
* public:
* 	virtual void function1() { std::cout << "vParent" << '\n'; };
* 	virtual void function2() { std::cout << "vParent" << '\n'; };
* };
* // наследуем *__vptr, он будет указывать на C1 VTable
* //	function1 указывает на С1::function1()
* //	function2 указывает на Parent::function2()
* class С1 : public Parent {
* public:
* 	virtual void function1() { std::cout << "vC1" << '\n'; };
* };
* // наследуем *__vptr, он будет указывать на C2 VTable
* //	function1 указывает на Parent::function1()
* //	function2 указывает на С2::function2()
* class С2 : public Parent {
* public:
* 	virtual void function2() { std::cout << "vC2" << '\n'; };
* };
* 
* int main() {
*	С1 c1;
*	Parent *cPtr = &c1;
*	cPtr->function1();	// вызов C1::function1() тк в виртуальной таблице function1 указывает на него!
* }
* 
* 'Почему медленее?'
*	1. Мы должны использовать *__vptr для перехода к виртуальной таблице.
*	2. Мы должны индексировать виртуальную таблицу, чтобы найти правильную функцию для вызова.
*	3. Наконец, выполнить вызов функции
* 
* В сравнение, 
*	обычный непрямой вызов - 2 операции
*	прямой вызов - 1 операция
* 
* #.'Интересно:' Запись чистой виртуальной функции в виртуальной таблице обычно содержит
*		либо нулевой указатель,
*		либо указывает на общую функцию, которая выводит ошибку, если не обнаружено переопределения

#endif // Виртуальные таблицы

#ifdef Чистые виртуальные функции, Интерфейсы и Абстрактные классы

* @.'Абстрактная функция' (Чистая виртуальная функция)
*		- метод, не имеющий определения совсем!
*	Сообщаем компилятору: "Реализацией этой функции займутся дочерние классы"
*	
*	! Делает класс абстрактным
*	! Дочерние классы должны определить чистые виртуальные функции
* 
* Пример
*	virtual int getValue() = 0;				// чистая виртуальная функция
* 
*	const char* sayHi() { return "Hi"; }	// невиртуальная функция				
*	virtual const char* getName() { return "Parent"; } // виртуальная функция
*	int doSomething() = 0;					// ошибка компиляции: нельзя невиртуальным функциям значение 0
* 
* @.'Абстрактный класс' - объекты которого нельзя создавать.
*	Например, если имеет одну и более 'чистых виртуальных функций'
* 
* 
* 'Можно предоставить реализацию по умолчанию'
* class Animal {
* public:
*	// абстрактная функция
*	virtual const char* speak() = 0;
* };
* 
* // реализация по умолчанию
* const char* Animal::speak() { return "buzz"; }
* 
* class Dragonfly: public Animal {
* public:
*	// определяем реализацией по умолчанию
*	virtual const char* spear() { return Animal::speak(); }
* }
* 
* 
* @.'Интерфейс' - класс, который не имеет переменных-членов и все методы которого
*		являются чистыми виртуальными (абстрактными) функциями!

#endif // Чистые виртуальные функции, Интерфейсы и Абстрактные классы

#ifdef Множественное Наследование

* 'Множественное наследование'
* Пример
* class Teacher: public Human, public Employee
*
* Проблемы:
*	'Методы с одним и тем же именем.'
*		- явно указать версию метода с помощью оператора ::
*	'Алмаз смерти'
*		- см ниже
*
* !.'Правило:' Используйте множественное наследование только в крайних случаях.
*
* @.'Алмаз смерти:'
*	! Виртуальные базовые классы всегда создаются перед невиртуальными базовыми классами
*	! Конструкторы виртуальных классов могут игнорироваться, если существует невиртуальный ответственный
*
* Пример, хотим:
*
*			PoweredDevice
*			->			<-
*	Scanner					Printer
*			<-			->
*				Copier
* 
* 'Пытаемся реализовать:'
* class PoweredDevice
* class Scanner: public PoweredDevice
* class Printer: public PoweredDevice
* class Copier: public Scanner, public Printer
* 
* На самом деле получим две копии PoweredDevice:
*	PoweredDevice			PoweredDevice
*		↑						↑
*	Scanner					Printer
*			<-			->
*				Copier
*
* 'Чтобы сделать родительский класс общим, используется ключевое слово' virtual
* class PoweredDevice
* class Scanner: virtual public PoweredDevice
* class Printer: virtual public PoweredDevice
* class Copier: public Scanner, public Printer
* 
* ! При создании Copier, он будет ответственнен за создание PoweredDevice, 
*		а конструкторы Scanner и Printer проигнорируются.
* ! При создании Scanner/Printer применяются обычные правила наследования.

#endif // Множественное Наследование

#ifdef Обрезка объектов std::reference_wrapper

* ! Чтобы не допустить обрезку объектов, передаем их по ссылке/указателю
* 
* 'Обрезаем класс'
* Пример
* Child child(7);
* 
* Parent &ref = child; // все ок: ссылка на объект child, который имеет Child и Parent.
* Parent *ptr = &child; // все ок: указатель на объект child, который имеет Child и Parent.
* Они видят только часть Parent объекта - child
* 
* Parent parent = child; // обрезка объекта
* В этом случае parent создает копию Parent child, часть Child child обрезается!
* 
* 
* 'Обрезка функции'
* int main() {
*	Child ch(7);
*	printName(ch);
* }
* 
* void printName(const Parent &parent) {	// все ок: I am a Child
*	std::cout << "I am a " << parent.getName() << '\n';
* }
* void printName(const Parent parent) {		// передача по значению = обрезание! I am a Parent
*	std::cout << "I am a " << parent.getName() << '\n';
* }
* 
* 
* 'Обрезка векторов'
* std::vector<Parent> v;
* v.push_back(Parent(7)); // добавляем объект класса Parent в наш вектор
* v.push_back(Child(8)); // добавляем объект класса Child в наш вектор
* 
* Обрезание Child!
*	ссылки не сработают (std::vector<Parent&> v;), поскольку std::vector 
*	должны быть объектами, которым можно переприсваивать значения.
*	Ссылки инициализируются лишь раз и переприсваивать им значения нельзя.
* 
* Способы решений:
* 'указатель на объекты' // морока с выделенной динамической памятью
* Пример
* std::vector<Parent*> v;
*	v.push_back(new Parent(7));
*	v.push_back(new Child(8));
* for (int i{}; i < v.size(); ++i)
*	delete v[i];
* 
* std::reference_wrapper // введет себя как ссылка, совместим с std::vector
*	Находится в #include <functional>
*	Объект не может быть анонимным
*	Для получения объекта используется метод get()
* Пример
* std::vector<std::reference_wrapper<Parent>> v;
* Parent p(7);
* Child ch(8);
* v.push_back(p);
* v.push_back(ch);

#endif // Обрезка объектов std::reference_wrapper

#ifdef оператор dynamic_cast

* 'Зачем нужен dynamic_cast?'
* - Применяя полиморфизм на практике вы часто будете сталкиваться с ситуациями,
*	когда у вас есть указатель на родительский класс, но вам нужно получить доступ к
*	данным, которые есть только в дочернем классе. 
*	(Понижающее приведение)
* 
*	! Не забыть проверку на нулевой указатель
*	! Не сработает:
*		Наследование типа private / protected
*		Классы не имеющих виртуальных таблиц
*		Случаи, связанные с виртуальными базовыми классами https://learn.microsoft.com/ru-ru/cpp/cpp/dynamic-cast-operator?view=msvc-170&viewFallbackFrom=vs-2019
* 
* Предпочтительнее использовать виртуальные функции
* 'Так в каких же случаях использовать dynamic_cast?'
*	Если вы не можете изменить родительский класс, чтобы добавить в него свою
*		виртуальную функцию (например, класс - часть Стандартной библиотеки С++)
*	Если вам нужен доступ к чему-либо, что есть ТОЛЬКО в дочернем классе.
*	Если добавление виртуальной функции в родительский класс не имеет смысла.
*		(использовать абстрактную функцию вместо создания объекта родителя)
* 
* Пример
* Parent *getObject(bool bReturnChild) {
*	if (bReturnChild)
*		return new Child(1, "Banana");
*	else
*		return new Parent(2);
* }
* int main() {
*	Parent *p = getObject(true);
*	Child *ch = dynamic_cast<Child*>(p);
*	if (ch) // проверка на нулевой указатель
*		std::cout << "The name of the Child is: << ch->getName() << '\n';
*	delete p;
* }
* 
* !.'Правило:' Всегда делайте проверку результата динамического приведения на нулевой указатель.
* 
* 
* static_cast vs dynamic_cast
*	! быстрее но опаснее
* При конвертации Parent* в Child* операция будет успешной, даже если Parent не будет 
*	указывать на объект класс Child.
* 
* Можно реализовать проверку через виртуальные функции
* enum ClassID
* {
*	PARENT,
*	CHILD
* };
* class Parent {
* public:
*	virtual ~Parent() {}
*	virtual ClassID getClassID() { return PARENT; }
* }
* class Child {
* public:
*	virtual ClassID getClassID() { return CHILD; }
* }
* 
* int main() {
*	Parent *p = getObject(true);
*	if (p->getClassID() == CHILD) {
*		Child *ch = static_cast<Child*>(p);
*		std::cout << "The name of the Child is: << ch->getName() << '\n';
*	}
*	delete p;
* }

#endif // оператор dynamic_cast

#ifdef Вывод объектов классов через оператор вывода

* Обычная перегрузка вывода не то, что нам нужно.
* Child ch;
* Parent &p = ch;
* std::cout << p << '\n'; // вызов перегрузки Parent, а хотели Child
* 
* operator<< не сделать виртуальным
*	1. Только методы могут быть виртуальными
*	2. Разные версии функции (отличается второй параметр), а значит нет переопределения
* 
* 
* Решение:
*	Сделать operator<< friend классу Parent.
*	Делегировать выполнение операции вывода виртуальному методу print()
* Пример
* class Parent
* {
* public:
* 	Parent(){}
* 	friend std::ostream &operator<< (std::ostream &out, const Parent &p) {
* 		return p.print(out);
* 	}
* 
* 	virtual std::ostream &print(std::ostream &out) const {
* 		out << "Parent";
* 		return out;
* 	}
* };
* class Child: public Parent
* {
* public:
* 	Child(){}
* 	virtual std::ostream &print(std::ostream &out) const {
* 		out << "Child";
* 		return out;
* 	}
* };
* 
* int main() {
*	Parent p;
*	std::cout << p << '\n';
* 
*	Child ch;
*	std::cout << ch << '\n';
*	
*	Parent &pref = ch;
*	std::cout << pref << '\n';
* };
*
*'В случае с объектом Parent'
* мы вызываем operator<<, который вызывает вирутальную функию print().
*поскольку мы ссылаемся на объект класса Parent, то p.print() вызывает Parent::print()
*
*'В случае с объектом Child'
* компилятор смотрит, есть ли operator<< -не находит.
* затем сиотрит, есть ли operator<< у Parent - есть.
* компилятор выполняет неявное преобразование(повышающее приведение) объекта Child в
* ссылку класса Parent и вызывает print()
* p.print() вызовет переопределение Child::print()
* (Мне кажется проще объяснить, через виртуальную таблицу)

#endif // Вывод объектов классов через оператор вывода


#include <iostream>
#include <string>
#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <cstring>
#include <array>
#include <ranges>
#include <vector>
#include <random>
#include <functional>
#include <fstream>
#include <cstdarg>
#include <cassert>
#include <cmath>
#include <initializer_list>
#include "constants.h"




#include "Circle.h"
#include "Triangle.h"

int getLargestRadius(const std::vector<Shape *> &v) {
	int largestRadius{};
	for (auto const &el : v)
	{
		if (Circle *c = dynamic_cast<Circle *>(el))
		{
			if (c->getRadius() > largestRadius)
				largestRadius = c->getRadius();
		}
	}

	return largestRadius;
}

int main() {
	std::vector<Shape*> v;
	v.push_back(new Circle(Point(1, 2, 3), 7));
	v.push_back(new Circle(Point(4, 5, 6), 3));
	v.push_back(new Triangle(Point(1, 2, 3), Point(4, 5, 6), Point(7, 8, 9)));

	for (auto const &el : v)
		std::cout << *el << '\n';

	std::cout << "The largest radius is: " << getLargestRadius(v) << '\n';

	for (auto const &el : v)
		delete el;
}