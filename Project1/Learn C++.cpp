/*
* Created by Logunov on 22/12/2022
* @comment: Прохождение и конспектирование курса "Ravesli"
* Спец. символы
*	Теория		-	@.'
*	Советы		-	#.'
*	Правила		-	!.'
*/

#ifdef Введение в программирование

* @.'Программа' -это 'набор инструкций', которые указывают компьютеру, что ему нужно делать.
*
* @.'Железо' - физическая часть, выполняющая эти инструкции.
*
* @.'Машинный код' - ограниченный набор инструкций, которое изначально понимает процессор.
*	1. Каждая команда состоит из определенной последовательности 0 и 1 (биты / двоичный код)
*	2. Каждый набор бит переводится процессором в инструкции для выполнения определенного задания (например, сравнить два числа)
*	Пример: 10110000 01100001
*
* @.'Язык Ассемблера' - первый ЯП, в котором каждая команда идентифицируется коротким именем.
*	1. Преимущество: производительность
*	2. Недостаток: программирование адаптируется к конкретному процессору.
*	Пример: mov al, 061h
*
* @.'Высокоуровневые ЯП' - позволяют писать и выполнять программы, не переживая о совместимости кода с разными архитектурами процессоров.
*	Программы, написанные на них также должны быть переведены в машинный код перед выполнением.
*	Есть два варианта это сделать:
*		1. Компиляция
*		2. Интерпретация
*
* @.'Компилятор' - программа, которая читает код и 'создает' автономную 'исполняемую программу', которую процессор понимает напрямую.
*	1. Преимущество: при повторном запуске программы компиляция не выполняется.
*	Пример: 
*		'Код ЯП				->	Компилятор		->	Исполняемый файл'
*		'Исполняемый файл	->	Процессор		->	Результат программы'
*		(C, C++, Pascal)
*
* @.'Интерпретатор' - программа, которая 'напрямую выполняет код', без его предыдущей компляции в исполняемый файл.
*	1. Преимущество: гибкость
*	2. Недостаток: процесс интерпретации выполняется повторно при каждом запуске программы
*	Пример: 
*		'Код ЯП				->	Интерпретатор	->	Процессор	->	Результат программы'
*		(Perl, JavaScript)
*	(*Java может как компилироваться, так и интерпретироваться)

#endif // Введение в программирование

#ifdef Введение в ЯП С и С++

* @.'Язык С "Си"'
* Разработан в 1972 г. Деннисом Ритчи, как язык для ОС.
*	Цель: минималистичный язык, который предоставлял бы эффективный доступ к памяти, с относительно быстрым выполнением
*	Стандарты:
*		ANSI 	C89
*		ISO		C90
*		ANSI	C99
*
* @.'Язык С++'
* Разработан в 1979 г. Бьёрном Страуструпом в качестве дополнения к Си.
*	Особенность: введение ООП
*	Стандарты:
*		ISO 1998
*		C++03
*		C++11 (* каждые 3 года)
*		C++14
*		C++17
*		C++20
*
* @.'Философия'
* Можно определить выражением "Доверять программисту"
*	Компилятор не будет мешать сделать что-то новое, что имеет смысл,
*		но также не будет мешать сделать что-то такое, что может привести к сбою программы.

#endif // Введение в языки программирования С и С++

#ifdef Введение в разработку ПО

* @.'Схема разработки ПО'
*
*	1.'Определите проблему'
*		Это шаг "Что?"
*		Необходимо понять, что вы хотите, чтобы ваша программа делала
*
*	2.'Разработайте решение'
*		Вопрос "Как?"
*		Каким образом можно решить проблему;
*			довольно часто пренебрегают, способов решения задачи может быть много,
*			только часть из них - хорошие, а часть - плохие
*		Как правило, хорошие решения обладают следующими характеристиками
*			'Простота'
*			'Хорошая документация'
*			'Модульный принцип' (может быть повторна использована, изменена позже)
*			'Надежность' (проверка на ошибки)
*
*	3.'Напишите программу, используя решение'
*
*	4.'Скомпилируйте программу'
*		@.'Работа компилятора' состоит из двух частей:
*			Проверка программы на соответствие правилам языка С++ (проверка синтаксиса)
*			Конвертация каждого исходного файла (*.cpp) с кодом в объектный файл на машинном языке
*
*	5.'Соедините объектные файлы (Линкинг)'
*		@.'Линкинг' - процесс связывания всех объектных файлов, генерируемых компилятором, в единую исполняемую программу.
*		Это делается при помощи программы Линкер / Компоновщик
*		'Исполняемый файл	->	Компиляция	->	Объектный файл	->	 Линкер	->	Исполняемый файл'
*
*	6.'Протестируйте и отладьте программу'
*		При помощи встроенного отладчика; также IDE имеет ряд возможностей:
*			Комплексная помощь
*			Дополнение кода
*			Система контроля версий

#endif // Введение в разработку ПО

#ifdef Режимы конфигурации Debug и Release

* @.'Конфигурация сборки' - это 'набор настроек' проекта, которые определяют принцип его построения.
*	Состоит из:
*		Имени исполняемого файла
*		Имени директории исполняемого файла
*		Имен директорий, в которых IDE будет искать другой код и файлы библиотек
*		Информации об отладке и параметрах оптимизации вашего проекта
* 
* @.'Debug' - предназначен для отладки программы.
*	Отключает все настройки по оптимизации
*	Включает информацию об отладке
* 
* @.'Release' - используется во время сборки программы для её дальнейшего выпуска
*	Оптимизируется по размеру и производительности
*	Не содержит дополнительную информацию об отладке

#endif // Режимы конфигурации Debug и Release

#ifdef Конфигурация компилятора

* Настроим проект Visual Studio для обучения
* Обозреватель решений	
*	->	Свойства (* установить 'Все конфигурации')
*		->	C/C++	
*			->	Общие	
*				->	'Уровень предупреждения 4'
*			->	Язык	
*				->	'Стандарт языка С++ (С++20?)'
*				->	'Отключить расширения языка Да'

#endif // Конфигурация компилятора

#ifdef Структура программ

* @.'Стейтмент' - распространенный тип инструкций, 'наименьшая независимая единица' в языке С++.
* Пример
*	// Стейтмент объявления
*	int x;
*	// Стейтмент присваивания
*	x = 5;
*	// Стейтмент вывода
*	std::cout << x;
* 
* @.'Выражение' - это математический объект, который создается для проведения вычисления и нахождения результата.
* Пример
*	2 + 3
*	2 + x
*	x + y
*	(2 + x) * (y - 3)
* 
* @.'Функция' - это последовательность стейтментов для выполнения определенного задания.
*	Каждая программа в С++ должна содержать главную функцию main(),
*		именно с первого стейтмента, находящегося в функции main() начинается выполнение всей программы.
* Пример
*	Функция max() может содержать стейтменты, для определения наибольшего из заданных чисел.
* 
* #.'Совет'
*	Размещайте функцию main() в файле .cpp с именем, совпадающим с именем проекта
* 
* @.'Библиотека' - это 'набор скомпилированного кода', который был 'упакован' 
*		для повторного использования в других программах
* Пример
*	#include <iostream>
* 
* @.'Пример простой программы'
*	1.	#include <iostream>
*	2.	
*	3.	int main()
*	4.	{
*	5.		std::cout << "Hello, world!";
*	6.		return 0;
*	7.	}
*	
*	Строка №1: 
*		@.'Директива препроцессора' - сообщает компилятору, что ему нужно выполнить определенное задание,
*			в данном случае подключить содержимое файла <iostream>
*
*	Строка №2:
*		Пустое пространство, игнорируется компилятором
*
*	Строка №3:
*		Объявление главной функции main()
*
*	Строка №4 и №7:
*		Указываем компилятору область видимости функции main()
*
*	Строка №5:
*		Стейтмент вывода.
*			std::cout - это специальный объект, используя который мы можем выводить данные на экран
*			<< - это оператор вывода
*			Всё, что отправляется в std::cout - выводится на экран ("Hello, world!")
*
*	Строка №6:
*		Оператор возврата 'return'
*		@.'Код состояния' - когда программа завершает свое выполнение, функция main() передает обратно в ОС
*			значение, которое указывает на результат выполнения программы
*				0 - всё хорошо
*				иначе - что-то пошло не так

#endif // Структура программ

#ifdef Комментарии

* @.'Комментарий' - Это строка/строки текста, вставленные в исходный код,
*		для объяснения того, что этот код делает.
* 
* 'Однострочный комментарий'	-	//
*	Лучше размещать над строками кода
*	Пример
*		// cout и endl находятся в библиотеке iostream
*		std::cout << «Hello, world!» << std::endl;
* 
* 'Многострочный комментарий'	-	/* */
*	Пример
*		/*
*		* Звёздочки слева
*		* упрощают чтение текста
*		*/
*
*		/* Это многострочный комментарий /* */ а это уже не комментарий */
*
* !.'Правило' - Не используйте вложенные комментарии!
* 
* @.'Как правильно писать комментарии?'
*	1. На уровне библиотек/программ/функций комментарии отвечают на вопрос
*		'Что?'
*	Пример
*		// Эта функция использует метод Ньютона для вычисления корня функции
* 
*	2. Внутри библиотек/программ/функций комментарии отвечают на вопрос
*		'Как?'
*	Пример
*		// Чтобы получить рандомный (случайный) элемент, мы выполняем следующее:
* 
*		// 1) Составляем список всех элементов.
*		// 2) Вычисляем среднее значение для каждого элемента, исходя из его веса, цвета и цены.
*		// 3) Выбираем любое число.
*		// 4) Определяем соответствие элемента случайно выбранному числу.
*		// 5) Возвращаем случайный элемент.
* 
*	3. На уровне стейтментов комментарии отвечают на вопрос
*		'Почему?'
*	Пример
*		// Мы решили использовать список вместо массива,
*		// потому что массивы осуществляют медленную вставку.
* 
* @.'Закомментировать код' - корвертировать одну или несколько строк кода в комментарии.
*	Таким образом, исключаем часть кода из компиляции.
*	В Visual Studio 'быстрые клавиши'
*		Закомментировать	-	'Ctrl + K' потом 'Ctrl + C'
*		Раскомментировать	-	'Ctrl + K' потом 'Ctrl + U'
*
* Причины закомментировать код:
*	1. Вы работаете над новой частью кода, которая пока что не рабочая.
*	2. Вы написали код, который компилируется, но работает не так, как нужно
*		и сейчас у вас нет времени с этим возиться.
*	3. Поиск корня ошибки, поочередно отключая части вашего кода.

#endif // Комментарии

#ifdef Объект

* @.'Объект' - это 'часть памяти', которая может хранить значение.
* При создании объекта, часть оперативной памяти выделяется для этого объекта.
* Аналогия
*	Почтовый ящик, куда мы помещаем информацию и откуда ее извлекаем
* 
* @.'Переменная' - Объект с именем.
* Стейтмент a = 8;
*	где 'а' - это переменная.
* 
* Все переменные являются l-values & r-values 
* 'l-values' - значение, которое 'имеет' свой собственный 'адрес' в памяти 
* 'r-values' - значение, 'не имеющего' постоянного 'адреса' в памяти
* (подробнее в следующих уроках)
* 
* Часто путают Инициализацию и Присваивание (?)
* 'Присваивание'
*	int a;
*	a = 8;
* 'Инициализация'
*	int a = 8
* 
* !.'Правило' - Если у вас изначально 'имеется значение' для переменной, то
*	'используйте инициализацию', вместо присваивания
* 
* При объявлении переменной, ей дается ячейка в памяти, при этом в ней будет хранится мусор
*	int a;
*	std::cout << a; // ошибка компиляции (в старых версиях выведет мусор по типу 2362346)

#endif // Объект

#ifdef Параметры и аргументы функций

* @.'Параметр функции' - это 'переменная, которая используется в функции' и значение
*	которой предоставляет caller (вызывающий объект).
* Пример
*	void printValue(int a) // один параметр типа int
*	{
*		std::cout << a << std::endl;
*	}
* 
* @.'Аргумент функции' - это 'значение', которое передается из caller - a в функцию
*	и которое 'указывается в скобках' при вызове функции в caller - e
* Пример
*	printValue(7); // 7 - аргумент функции printValue()
*
* 'Рекомендации при написании функции'
*	1. Код, который появляется более одного раза в программе, лучше переписать в виде функции.
*	2. Код, который используется для сортировки чего-либо, лучше записать в виде отдельной функции.
*	3. Функция должна выполнять одно задание.
*	4. Когда функция становится слишком большой, сложной или непонятной - её следует разбить на несколько подфункций.
*
* @.'Локальная область видимости' - параметры функции, переменные, которые объявлены внутри функции.
*	Создаются в точке объявления и уничтожаются, когда выходят из области видимости.
* 
* !.'Правило' - Имена, которые используются внутри функции (включая параметры),
*	доступны/видны только внутри этой же функции

#endif // Параметры и аргументы функций

#ifdef Ключевые слова и идентификаторы

* @.'Ключевое слово' - Слова в ЯП (С++), зарезервированные для собственного использования
* Пример
*	auto
*	break
*	char
* @.'Идентификатор' - Имя переменной, функции, класса или другого объекта на языке С++.
* !.'Правила' которые нужно соблюдать:
*	1. Идентификатор не может быть ключевым словом.
*	2. Идентификатор может состоять только из букв, цифр и символов подчёркивания
*	3. Идентификатор должен начинаться с буквы
*	4. С++ различает нижний регистр от верхнего (nvalue не тоже самое что nValue)
* Пример 
*	// корректно (разделяется символом подчёркивания)
*	int my_variable_name;
*	void my_function_name();	
* 
*	// корректно (используется CamelCase "Верблюжий Стиль"
*	int myVariableName;
*	void myFunctionName();
* 
*	// некорректно (пробелы запрещены)
*	int my variable name;
*	void my function name();
* 
*	// работает, но не рекомендуется (следует начинать с буквы в нижнем регистре)
*	int MyVariableName;
*	void MyFunctionName();
* 
* #.'Рекомендации':
*	1. При работе с чужим кодом, придерживайтесь его стиля
*	2. Не начинайте ваши имена с символа подчёркивания, они уже зарезервированы для ОС, библиотеки
*		и используются компилятором
*	3. В качестве идентификаторов используйте те имена, которые реально описывают то, чем является объект
*	4. Уточняющий комментарий всегда будет плюсом (иногда выходит слишком длинное название)
* 
* *'Примечание:' Можно использовать тривиальные имена для переменных,
*		которые имеют тривиальное использование (переменные в цикле, простые математич. функции и тд)

#endif // Ключевые слова и идентификаторы

#ifdef Операторы

* @.'Литерал' - это 'фиксированное значение', которое записывается в исходном коде.
* Пример
*	int a = 3;						// a - это переменная, 3 - литерал
*	std::cout << 5 + 2;				// 5 + 2 - выражение, 5 и 2 - литералы
*	std::cout << "Hello, world!";	// "Hello, world!" - тоже литерал
* 
* @.'Операнд' - это 'данные, с которыми работает выражение'
* 
* @.'Оператор' - это спец. 'символы, работающие с операндом' для получения нового значения.
* 
* @.'Операторы бывают трёх типов'
*	1. Унарные		// -7
*	2. Бинарные		// 5 + 2
*	3. Тернарные	// только один ?:

#endif // Операторы

#ifdef Базовое форматирование кода

* Пробелы, используемые для читабельности кода, также игнорируются компилятором
*	(здесь обойдемся без частных случаев)
* 
* #.'Рекомендации':
*	1. Вместо табуляции ('\t') используйте 4 пробела 
*		(для переноса правильных отступов на другие IDE)
* 
*	2. Фигурные скобки
*		На одном уровне
*			int main()
*			{
*			}
*		Или такой вариант
*			int main() {
*			}
* 
*	3. Каждый стейтмент функции должен быть с соответствующим отступом (tab)
*			int main()
*			{
*				std::cout << "Hello, world!" << std::endl;
*				std::cout << "Nice to meet you." << std::endl;
*			}
* 
*	4. Строки не должны быть слишком длинными (?).
*		До 80 символов - это оптимальный максимум строки
* 
*	5. Если длинная строка разбита на части с помощью оператора, то этот оператор должен находиться
*		в конце этой же строки.
*			std::cout << "This is a really, really, really, really, really, really, really, " <<
*				"really long line" << std::endl;
*			if (condition == "firstName" ||
*				condition == "lastName")
* 
*	6. Используйте пробелы и пропуски строк между стейтментами, для улучшения читабельности вашего кода
*			nConst			= 57;
*			nPricePerItem	= 24;
*			nValue			= 5;
*			nNumberOfItems	= 17;

#endif // Базовое форматирование кода

#ifdef Прототип функции и Предварительное объявление

* *'Проблема:'
* int main() {
*	std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
*	return 0;
* }
* 
* int add(int x, int y) {
*	return x + y;
* }
* // add: идентификатор не найден
* // компилятор, находясь в теле main(), еще не знает о функции add(int, int)
* 
* 
* @.'Предварительное объявление' - 'сообщает компилятору о существовании идентификатора' ДО 
*		его фактического определения
* Пример
*	int add(int x, int y) {
*		return x + y;
*	}
* 
*	int main() {
*		std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
*		return 0;
*	}
* 
* @.'Прототип функции' - состоит из типа возврата функции, её имени и параметров.
*	В кратком прототипе можно опустить имена параметров функции
* Пример 
*	int add(int, int);	
* 
*	int main() {
*		std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
*		return 0;
*	}
* 
*	int add(int x, int y) {
*		return x + y;
*	}
* 
* 
* @.'Определение' - вызывает выделение памяти для идентификатора.
* Пример
*	int add(int x, int y)	// определяем функцию z
*	{
*		int z = x + y;		// определяем переменную z
*		return z;
*	}
* !.'Правила':
*	1. Внутри файла функция/объект/тип/шаблон могут иметь только 'одно определение'
*	2. Внутри программы объект/функция могут иметь только 'одно определение'
*	3. Внутри программы типы/шаблоны функций/встроенные функции могут иметь 'несколько определений',
*		'если' они 'идентичны'
*	Нарушение правила 1 - ошибка компиляции
*	Нарушение правила 2 или 3 - ошибка линкинга
*
* @.'Объявление' - это стейтмент, который сообщает компилятору о существовании идентификатора и о его типе.
* Пример
*	int add(int x, int y);	// объявляем функцию add
*	int x;					// объявляем переменную x
* 
* 'Определение' - это то, что 'обеспечит' корректную работу как 'компилятора', так и 'линкера'
* 'Объявление' - всё, что необходимо 'для' корректной работы 'компилятора', 'но недостаточно для' корректной работы 'линкера'

#endif // Прототип функции и Предварительное объявление

#ifdef Директивы препроцессора

* @.'Препроцессор' - отдельная программа, которая 'выполняется перед компиляцией'.
* При запуске программы, препроцессор просматривает код сверху вниз, файл за файлом, в поиске директив.
* 
* @.'Директивы' - 'специальные команды', которые начинаются с символа '#' и НЕ заканчиваются ';'
* 
* 'Директива #include' - препроцессор 'копирует содержимое подключаемого файла' 
*	в текущий файл сразу после строки с #include
*		Угловые скобки < >
*			Сообщает препроцессору искать файл в 'системных путях'
*			#include <filename>
*		Двойные кавычки " "
*			Сообщает препроцессору искать файл в 'текущей директории проекта'
*			#include "filename"
* 
* 'Директива #define' - используется для создания макросов
* 
* @.'Макрос' - это правило, которое определяет 'конвертацию идентификатора в указанные данные'.
*	Есть два типа макросов
*		'Макросы-функции' ведут себя как функции и используются в тех же целях.
*		'Макросы-объекты' 
*			Пример
*			#define MY_FAVORITE_NUMBER 9	// MY_FAVORITE_NUMBER заменяется числом 9
*			#define USE_YEN					// USE_YEN заменяется пустым местом
*				'Не рекомендуется использовать как замену!'
*					1. Из-за глобальной области видимости
*					2. Из-за невозможности увидеть заменяемое значение в отладчике
*
* @.!'Правило:' Не используйте директиву #define для создания символьных констант
* 
* 'Директива условной компиляции'
*	#ifdef		// Было ли определено с помощью #define?
*	#ifndef		// Было ли НЕ определено с помощью #define?
*	#endif		// Конец условной компиляции
* Пример ('Header Guards')
*	@.'Header Guards'
*	Часто используется в '.h' файлах, для предотвращения копирования одного и того же файла.
*		#ifndef SOME_UNIQUE_NAME_HERE
*		#define SOME_UNIQUE_NAME_HERE
*
*		// Основная часть кода
* 
*		#endif
* 
*	#pragma once - альтернатива примеру выше, короче и менее подвержена ошибкам.
*		НО, не является официальной частью языка С++ и не все компиляторы её поддерживают.
*		Поэтому рекомендуется использовать Header Guards (?)

#endif // Директивы препроцессора

#ifdef Конфликт имен и std namespace

* Большинство конфликтов имен происходят в двух случаях:
*	1. Файлы добавленные в один проект, имею функцию с одинаковыми именами (линкинг)
*	2. Файл .cpp подключает заголовочный файл, в котором идентификатор конфликтует с 
*		идентификатором из файла .cpp (компиляция)
* 
* Весь функционал Стандартной библиотеки С++ определен внутри пространства имен std (сокр. от "standart")
* 
* @.'Оператор разрешения области видимости ::' - способ сообщить компилятору, что идентификатор находится в 
*	определенном пространстве имен.
* Пример
*	// Сообщаем, что хотим использовать cout из пространства имен std
*	std::cout << "Hello, world!";

#endif // Конфликт имен и std namespace

#ifdef Разработка ваших первых программ

* Шаг №1: 'Определите проблему'
*	Сформулировать проблему, которая решит ваша задача.
*	Пример
*		Я хочу написать программу-справочник для удобного хранения и редактирования
*			всех телефонных номеров и звонков.
* 
* Шаг №2: 'Определите свой инструментарий, цели и план бэкапа'
*	Для опытных будет не мало дополнительных пунктов:
*		Какая ваша целевая аудитория и какие у нее потребности?
*		На какой архитектуре/ОС ваша программа будет работать?
*		Какой инструментарий вы будете использовать?
*		Будете ли вы разрабатывать программу в одиночку или в составе команды?
*		Анализ требований.
*		Определение стратегий тестирования/обратной связи/релиза.
*		Создание плана бэкапа в случае неожиданных проблем.
* 
* Шаг №3: 'Разбейте проблему на части'
*	Любое сложное — это совокупность множества простого.
*	Задача: 
*		Написать доклад о картошке
*	Разделим на подзадачи:
*		Написать доклад о картошке
*			Поиск информации о картошке
*			Создание плана
*			Заполнение каждого пункта плана подробной информацией
*			Заключение
*	Звучит всё еще расплывчато - разобьем подпункты:
*		Написать доклад о картошке
*			Поиск информации о картошке
*				Сходить в библиотеку за книжками о картошке
*				Поискать информацию в Интернете
*				Делать заметки в соответствующих разделах из справочного материала
*			Создание плана
*				Информация о выращивании
*				Информация об обработке
*				Информация об удобрениях
*			Заполнение каждого пункта плана подробной информацией
*			Заключение
* 
* Шаг №4: 'Определите последовательность событий'
*	Надо определить, как связать все пункты вместе.
*	Также стоит учесть, что для выполнения одной задачи, может потребоваться выполнение другой.
* 
* Шаг №5: 'Определите данные ввода и данные вывода на каждом этапе'
* Шаг №6: 'Позаботьтесь о деталях'
* Шаг №7: 'Соедините данные ввода с данными вывода в программе'

#endif // Разработка ваших первых программ

#ifdef Отладка программ

* Типы ошибок
*	@.'Синтаксическая ошибка' - когда вы пишете код, которые не соответствует правилам грамматики ЯП С++
*	@.'Семантическая ошибка' - когда код синтаксически правильные, но делает не то, что задумал программист
* 
* @.'Отладчик'/'Дебаггер' - программа, которая позволяет программисту 'контролировать выполнение кода'.
*	Например, для выполнения программы пошагово, последовательно изучая значения переменных в программе.
* 
* 'Примечание:' убедитесь, что вы находитесь в режиме конфигурации Debug
* 
* @.'Степпинг' - возможность отладчика выполнять код пошагово (строка за строкой).
*	Есть три команды степпинга:
*		'Шаг с заходом'							| F11
*		'Шаг с обходом'							| F10
*		'Шаг с выходом'							| shift + F11
* 
* Команда "Выполнить до текущей позиции"		| ПКМ по строке и Выполнить до текущей позиции
*	Выполнит весь код до строки, обозначенной курсором.					
* 
* Команда "Продолжить"							| F5
*	Продолжит выполнение до конца программы или до следующей контрольной точки.
* 
* @.'Точка останова' - 'специальные маркеры',	| ЛКМ по свободной зоне слева от номера строки
*	на которых отладчик 'останавливает процесс выполнения' программы.
* 
* @.'Отслеживание переменных' - это процесс проверки значений переменных во время отладки.
* @.'Стек вызовов' - это список всех активныхз функций, которые вызывались до текущего местоположения.
*	'Отладка'	->	'Окна'	->	'Стек вызовов'

#endif // Отладка программ

#ifdef Инициализация, присваивание и объявление переменных

* С++ поддерживает 3 основных способа инициализации переменных.
*	1. Копирующая инициализация
*		int nValue = 5;
*	2. Прямая инициализация
*		int nValue(5);
*	3. uniform-шнициализация
*		Преимущество: компилятор выдаст предупреждение или сообщение об ошибке.
*			int nValue{5};
*			// по умолчанию значение 0
*			int nValue{}
*			Преимущество:
* 
* !.'Правило:' Используйте uniform-шнициализацию
* 
* Объеявление нескольких переменных:
*	int a, b;
* 
*	int a;
*	int b;
* 
* !.'Правило:' Объявляйте переменные как можно ближе к их первому использованию.

#endif // Инициализация, присваивание и объявление переменных

#ifdef Тип данных void

* @.'void' - тип данных, который означает 'отсутствие любого типа данных'
* 
* Переменные не могут быть типа void
* 
* Использование:
*	1. Функция не возвращает значения
*		void writeValue(int x)
*	2. Функция не имеет никаких параметров (перешло из Си)
*		int getValue(void)	<=>	int getValue()
*	3. TO DO

#endif // Тип данных void

#ifdef Тип данных

* 'Категория'						'Тип'				'Минимальный размер'
* Логический тип данных				bool				1Б
* 
* Символьный тип данных				char				1Б
*									wchar_t				1Б
*									wchar16_t			2Б
*									wchat32_t			4Б
* 
* Целочисленный тип данных			short				2Б
*									int					2Б
*									long				4Б
*									long long			8Б
* 
* Тип данных с плавающей запятой	float				4Б
*									double				8Б
* 									long double			8Б
* 
* 
* 'Про целочисленные типы:'
* @.'Оператор sizeof' - унарный, вычисляет и возвращает 'размер' переменной или определенного типа
*		'данных' в байтах
* 
* @.'Ключевое слово signed' - обозначает, что переменная может содержать '+' и '-' значения.
*	По умолчанию перед типом пишется signed
* 
* @.'Ключевое слово unsigned' - обозначает, что переменная может содержать только '+' значения.
* 
* Диапазон значений (пример)
*	1Б signed			-128	:	127
*	1Б unsigned		0		:	255
* 
* !!!Как правило, unsigned избегают, из-за непредвиденных ошибок.
*	(при смешивании signed и unsigned)
* 
* @.'Переполнение' - 'потеря бита' из-за того, что переменной 'не было выделено достаточно памяти' для их хранения.
* Пример
*	4-битная переменная:
*		21 = 0b10101 (двоичный вид)
*			крайний левый бит потеряется, поскольку выделено 4 бита.
*			получим: 0b0101 = 5
* 
* !.'Правило:' Никогда не допускайте возникновения переполнения в ваших программах!
* 
* При делении 'целых' чисел в C++ дробная часть 'отбрасывается!'
* Пример
*	// Знаем
*	8 / 5 = 1.6
*	// Компьютер
*	8 / 5 = 1
* 
* Размер целочисленных типов не является фиксированным,
*	началось с языка Си, когда производительность имела первостепенное значение,
*	чтобы компилятор мог самостоятельно подобрать наиболее подходящий размер для определенного
*	типа данных в зависимости от компьютерной архитектуры.
* 
* В С++ добавили набор целочисленных типов фиксированного размера
*	int8_t	uint8_t
*	int16_t	uint16_t
*	int32_t	uint32_t
*	int64_t	uint64_t
* 
*	*До С++11 требуется подключить <stdint.h>
* 
*	*'Предупреждение', int8_t uint8_t могут быть обработаны как тип char
* 
* 
* 'Про типы данных с плавающей точкой:'
* Следует знать, как правильно писать литералы:
*	5		-	int
*	5.0		-	double
*	5.		-	double
*	5.0f	-	float
*	5.f		-	float
* 
* 'Экспоненциальная запись'
*	5000.0		=	5e3
*	0.05		=	5e-2
*	42030		=	4.203e4		// отбрасываем последний 0
*	0.0078900	=	7.8900e-3	// из дробной части 0 не отбрасывается
* 
* Можем переопределить 'точность' cout, используя функцию std::setprecision(),
*	которая находится в заголовочном файле <iomanip>
* Пример
*	float f		=	3.33333333333333333333333333333333333333f;
*	double d	=	3.33333333333333333333333333333333333333;
*	std::cout << std::setprecision(17);
*	std::cout << f << std::endl;
*	std::cout << d << std::endl;
* Вывод:
*	3.3333332538604736
*	3.3333333333333335
* 
* 'Ошибки округления'
* Пример
* double a{1.0};
* double b{0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1};
* std::cout << a << '\n' << b << std::endl;
* Вывод:
*	1
*	0.99999999999999989
* 
* @.'Сравнение чисел с плавающей запятой'
* Пример 'Различных разработчиков'
*	include <cmath>
*	bool isAlmostEqial(double a, double b, double epsilon) {
*		return fabs(a - b) <= epsilon;
*	}
* Недостаток: всегда нужно подбирать нужны epsilon
* 
* Пример 'Кнута'  
*	include <cmath>
*	bool approximatelyEqual(double a, double b, double epsilon) {
*		return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
*	}
* Преимущество: epsilon представляет собой процентное соотношение.
* Недостаток: сравнение чисел близких к нулю
* 
* Пример 'Всё вместе'
*	#include <cmath>
*	bool vmeste(double a, double b, double absEpsilon, double relEpsilon) {
*		double diff = fabs(a - b);
*		if (diff <= absEpsilon)
*			return true;
* 
*		return diff <= ((fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * relEpsilon);
*	}
*
* 'nan и inf'
*	inf - бесконечность
*	nan - не число (несколько видов)
* Пример
*	double zero = 0.0;
*	double posinf = 5.0 / zero;
*	double neginf = 5.0 / zero;
*	double nan = zero / zero;
*	std::cout << 
*		posinf << '\n' <<
*		neginf << '\n' <<
*		nan << std::endl;
* Вывод
*	inf
*	-inf
*	-nan(ind)
* 
* 
* 'Про логический тип данных:'
* Чтобы std::cout выводил true или false, используйте манипулятор std::boolalpha
*	std::cout << std::boolalpha;
* 
* В С++ нет 'XOR', можно сымитировать, используя оператор неравенства (!=)
* if (a != b) ... // a XOR b (предполагается, что a и b типа bool)
*
* 'Про char'
* Интерпретируется как ASCII-символ
*	(существует таблица, где числам от 0 до 127 назначен свой символ)
*	Пример
*		char ch(5);		// инициализация целым числом 5
*		char ch('5');	// инициализация символом '5' (не тоже самое)
* 
* @.'Оператор static_cast' - лучший 'способ конвертации переменной' из одного типа данных в другой
* Пример
*	char ch(97)
*	std::cout << ch << std::endl;
*	std::cout << static_cast<int>(ch) << std::endl;
* Вывод
*	a
*	97
* 'Примечание:' У static_cast 'нет проверки' на диапазон значений; 
*	мы можем случайно вызвать 'переполнение'.
* 
* @.'Управляющие символы' - Начинаются с '\', имеют свое назначение.
*	'Название'					'Символ'		'Значение'
*	Предупреждение				\a				Звуковой сигнал
*	Backspace					\b				Перемещ. курсора на одну позицию назад
*	Formfeed					\f				Перемещ. курсора к следующей логич. странице (?)
*	Newline						\n				Перемещ. курсора на следующую строку
*	Carriage Return				\r				Перемещ. курсора в начадл строки
*	Horizontal tab				\t				Вставка горизонтального TAB-a
*	Vertical tab				\v				Вставка вертикального TAB-a
*	Одинарная кавычка			\'				'Вставка одинарной кавычки (или апострофа)
*	Двойная кавычка				\"				"Вставка двойной кавычки
*	Бэкслеш						\\				Вставка обратной косой черты
*	Вопросительный знак			\?				Вставка знака вопроса
*	Восьмеричное число			\(number)		Перевод числа из восьмеричной СС в тип char
*	Шестнадцатеричное число		\x(number		Перевод числа из шестнадцатеричной СС в тип char
* 
* '\n' vs std::endl;
*	Преимущество 'std::endl очищает буфер'
*		Используйте std::endl в случаях, где нужно, чтобы данные выводились сразу же
*			* Запись в файл
*			* При обновлении индикатора состояния процесса
*		'\n' - во всех остальных случаях
	
#endif // Тип данных

#ifdef Константы

* !.'Правило:' Любая переменная, которая не должна изменять свое значение после инициализации,
*	должна быть объявлена с помощью спецификатора const или constexpr
* 
* Константы объявляются с 'инициализацией'.
* 
* Есть два вида констант:
*	Константа времени выполнения ('const')
*		- значение определится во время выполнения программы
*	Константа времени компиляции ('constexpr')
*		- значение определится во время компиляции программы
* 
* 'Алгоритм использования символьных констант:'
*	1. Создать 'заголовочный файл' для хранения констант.
*	2. В заголовочном файле объявить пространство имён.
*	3. Добавить все константы в созданное пространство имён.
*	4. #include этот файл везде, где нужны константы.
* Пример 
*	"constants.h"
*		#ifndef CONSTANTS_H
*		#define CONSTANTS_H
*		
*		namespace constants
*		{
*			const double pi{ 3.14159 };
*		}
* 
*		#endif CONSTANTS_H
* 
*	".cpp файл"
*		#include "constants.h"
* 
*		//...
*		double circumference = 2 * radius * constants::pi;
*		//...		

#endif // Константы

#ifdef Операторы

* // Тут мне стало лень
* !.'Правило:' Используйте 'префиксный' инкремент и 'префиксный' декремент вместо
*		постфиксного инкремента и постфиксного декремента.
* 
* #.'Совет:' Всегда заключайте в скобки условную часть тернарного оператора, а
*		лучше весь тернарный оператор.

#endif // Операторы

#ifdef Побитовые операторы

* @.'Таблица побитовых операторов'
*	'Оператор'					'Символ'
*	Побитовый сдвиг влево		<<		
*	Побитовый сдвиг вправо		>>		
*	Побитовое НЕ				~		
*	Побитовое И					&		
*	Побитовое ИЛИ				|		
*	Побитовое исключающее ИЛИ	^
* 
* !.'Правило:' При работе с побитовыми операторами используйте целочисленные типы данных unsigned.
* 
* См. примеры на "binary.h"
* 
* 'Битовые флаги'
*	const unsigned char option1 = 0x01; // шестнадцатеричный литерал для 0000 0001
*	const unsigned char option2 = 0x02; // шестнадцатеричный литерал для 0000 0010
*	const unsigned char option3 = 0x04; // шестнадцатеричный литерал для 0000 0100
*	const unsigned char option4 = 0x08; // шестнадцатеричный литерал для 0000 1000
*	const unsigned char option5 = 0x10; // шестнадцатеричный литерал для 0001 0000
*	const unsigned char option6 = 0x20; // шестнадцатеричный литерал для 0010 0000
*	const unsigned char option7 = 0x40; // шестнадцатеричный литерал для 0100 0000
*	const unsigned char option8 = 0x80; // шестнадцатеричный литерал для 1000 0000
* Пример
*	unsigned char myflags = 0; // все флаги/параметры отключены до старта
*	
*	myFlags |= option4;					// включаем option4
*	myFlags |= (option4 | option5);		// включаем option4 и option5
* 
*	myFlags &= ~option4;				// выключаем option4
*	myFlags &= ~(option4 | option5);	// выключаем option4 и option5
* 
*	myFlags ^= option4;					// изменить состояние option4
*	myFlags ^= (option4 | option5);		// изменить состояние option4 и option5
* 
* @.'bitset'
*	#include <bitset>
* Пример
*	std::bitset<8> bits;
*	std::bitset<8> bits(option1 | option2); // начнем с включенных option1 и option2
*	std::bitset<8> morebits(0x2) ; // начнем с битового шаблона 0000 0010
* 'Функции'
*		test()		-	узнать значение бита
*		set()		-	включить бит
*		reset()		-	выключить бит
*		flip		-	перевернуть бит
* 
* @.'Битовые маски' - запрашивание сразу нескольких бит, в целях их модификации как группы.
*
* 'САМОПИСНЫЙ ПРИМЕР' см.
*	"binary.h"
*	"binary.cpp"

#endif // Побитовые операторы

#ifdef Область видимости
* @.'Блоки стейтментов' - группа стейтментов, которые обрабатываются компилятором как одна инструкция.
* Начинается с символа '{' и заканчивается символом '}' 
* Пример
* int main() 
* // внешний блок
* {
*	// переменная m создается и инициализируется здесь
*	int m(4); 
*	// начало вложенного блока
*	{
*		// переменная k создается и инициализируется здесь
*		double k(5.0);
*	} 
*	// Переменная k не может быть использована здесь, так как она уже уничтожена!
* 
* @.'Уровень вложенности блоков' - максимальное количество блоков, которые могут находиться в любой точке функции.
* 
* @.'Сокрытие имен'
* Пример
* int main() {
*	// внешняя переменная oranges
*	int oranges(5);
*	if (oranges >= 5)
* 
*	// вложенный блок
*	{
*		// скрывается внешняя переменная oranges
*		int oranges; 
*		// здесь мы присваиваем значение 10 вложенной переменной oranges, не внешней!
*		oranges = 10; 
*		// выводим значение вложенной переменной oranges
*		std::cout << oranges << std::endl;
*	// вложенная переменная oranges уничтожается
*	}
*	
*	// Идентификатор oranges опять относится к внешней переменной oranges
*	std::cout << oranges << std::endl; // выводим значение внешней переменной oranges
* 
* 
* @.'Глобальные переменные' - переменные, объявленные 'вне блока'.
* При одинаковых именах, можно компилятору сообщить, какую версию использовать при помощи оператора ::
* Пример
* int value{ 8 };
* int main() {
*	int value = 8;
*	value++;		// увеличивается локальная переменная
*	::value--;		// уменьшается глобальная переменная
* 
*	std::cout << "Global value: " << ::value << '\n';
*	std::cout << "Local value: " << value << '\n';
*
* @.'Область видимости' - олпределяет, где 'доступен идентификатор' для использования.
*	1. Локальная/блочная область видимости: доступны только в пределах блока, в котором они объявлены
*			Локальные переменные
*			Параметры функции
*	2. Глобальная/файловая область видимости: доступны в любом месте файла
*			Глобальные переменные
* 
* @.'Продолжительность жизни' - определяется, где 'создается' и где 'уничтожается' переменная
*	1. Автоматическая: создаются в точке определения и уничтожаются при выходе из блока.
*			Локальные переменные
*	2. Статическая: когда программа запускается и уничтожаются при ее завершении.
*			Глобальные переменные
*			Статические локальные переменные
*	3. Динамическая: создаются и уничтожаются по запросу программиста
*			Динамические переменные
* 
* @.'Связь' - определяет, относятся ли 'несколько упоминаний одного идентификатора' к одному и тому же идентификатору или нет.
*	1. Без связей: ссылаются сами на себя.
*			Локальные переменные
*			Пользовательские типы данных (enum, typedef и классы, объявленные внутри блока)
*				int x;
*				static int x;
*				int *x = new int;
*				void foo(int x);
*	2. Внутренняя связь: доступны в любом месте файла, в котором они объявлены.
*			Статические глобальные переменные
*			Константные глобальные переменные
*			Статические функции
*				static int g_x;
*				const int g_x(1);
*	3. Внешняя связь: доступны в любом месте файла, в котором они объявлены, так и в других файлах (через предварит. объявление)
*			Обычные функции
*			Неконстантные глобальные переменные
*			Внешние константные глобальные переменные
*			Определяемые пользователем типы данных (enum, typedef и классы с глобальной областью видимости)
*				int g_x;
*				extern const int g_x(1)
* 
* @.'Переменная без связей' - переменная с 'локальной' областью видимости, которая относится 'только к блоку'
*	в котором она определена
* 
* @.'Статическая переменная' - переменная, имеющая внутренние связи, может использоваться только 'внутри файла'
*	Ключевое слово static
* 
* @.'Внешняя переменная' - переменная, имеющая внешние связи, может использоваться во всех файлах
*	Ключевое слово extern
*	Чтобы использовать, необходимо предварительное объявление переменной с использованием ключевого слова extern
* 
* #.'По умолчанию:' 
*		Переменная объявленная вне блока - extern (внешние)
*		НО константные переменные вне блока - static (внутренние)
*		Функции - extern
* 
* #.'Объявление констант extern:'
* Пример
*	"constants.h"
*		namespace Constants
*		{
*			extern const double pi;
*			extern const double avogadro;
*			extern const double gravity;
*		}
*	"constants.cpp"
*		namespace Constants
*		{
*			extern const double pi(3.14159);
*			extern const double avogadro(6.0221413e23);
*			extern const double gravity(9.2);
*		}
*	Преимущество: любые изменения, сделанные в constants.cpp, потребуют перекомпиляции только этого файла
*	Недостаток: такие костанты не будут считаться константами типа compile-time
* 
* #.'Совет:' Используйте префикс - 'g_' для идентификации неконстантных глобальных переменных
*	(а лучше эти переменные не использовать - '//')
*	Если используем:
*		инкапсулируем, делая переменную static и получая доступ через функции,
*		сводим случаи, где эти переменные могут измениться к минимуму!
*	
* 'САМОПИСНЫЙ ПРИМЕР' см. 
*	"global.h"
*	"global.cpp"

#endif // Область видимости

#ifdef using

* @.'using-объявление'
* int main() {
*	// using-объявление сообщает компилятору, что cout следует обрабатывать как std::cout
*	using std::cout;
*	cout << "Hello, world!";
* }
* 
* @.'using-директива' (стараться избегать)
* int main() {
*	// using-директива сообщает компилятору, что мы используем все объекты из пространства имен std
*	using namespace std;
*	cout << "Hello, world!";
* }
* Пример конфликта
*	#include <iostream>
* 
*	int cout() { 
*		return 4;
*	}
* 
*	int main() {
*		using namespace std;
*		cout << "Hellom world!";
*	}
* 
* !.'Правило:' Ограничивайте using-стейтменты при помощи локальной области видимости { }

#endif // using

#ifdef Преобразование типов

* @.'Неявное преобразование типов' - всякий раз, когда требуется один тип данных, а предоставляется другой и 
*	пользователь не указывает компилятору, как выполнить конвертацию.
*		1. 'Числовое расширение'	|	Безопасно, не приводит к потере данных
*			* С плавающей точкой
*				float -> double
*			* Интегральное
*				int -> long
*		2. 'Числовая конверсия'		|	Может привести к переполнение, потере точности и тд
*				double -> float
*				int -> char
* 
* Приоритет типов операндов:
*	long double			(самый высокий)
*	double
*	float
*	unsigned long long
*	long long
*	unsigned long
*	long
*	unsigned int
*	int					(самый низкий)
* 
* Пример
*	short x(3);
*	short y(6);
*	std::cout << typeid(x + y).name() << " " << x + y << std::endl;
*	// Поскольку short меньше по размеру/диапазону типа int, то он подвергается интегральному расширению в тип int
*	Результат: int 9
* 
*	double x(3.);
*	short y(2);
*	std::cout << typeid(x + y).name() << " " << x + y << std::endl;
*	// short подвергается интегральному расширению в int
*	// поскольку int и double не совпадают, но double находится выше в иерархии типов, то целое число 2 теперь 2.0 типа double
*	Результат: double 5
* 
*	std::cout << 5u - 10;
*	// здесь int (signed int) подвергается расширению в unsigned int (по приоритету)
*	// знаем, что первый бит у int'a используется для определения знака (0000'0000'0000'0101 - 1000'0000'0000'1010
*	Результат: 4294967291
*	Чтобы подробнее расмотреть это, используйте следующий код:
*		#include <iostream>
*		#include <bitset>
*		int main() {
*			unsigned int a		= 5u;
*			int b				= -10;
*			unsigned int result	= a + b;
*			std::bitset<16> binA(a), binB(b), binResult(result);
*			std::cout <<
*				binA << '\n' << 
*				binB << '\n' << 
*				binResult << '\n';
*		}
* 
* @.'Явное преобразование' - используя оператор явного преобразования, указать компилятору как выполнить преобразование
*	5 видов операций:
*		C-style
*			(int)x или
*			int(x)
*			! Не проверяется во время компиляции, лучше не использовать
*		static_cast
*			static_cast<int>(x)
*		const_cast
*		dynamic_cast
*		reinterpret_cast
* 

#endif // Преобразование типов

#ifdef Перечисления

* @.'Перечисление' - тип данных, где любое 'значение' определяется как 'символьная константа'.
*	enum Colors
*	{
*		COLOR_RED,		// 0
*		COLOR_GREEN,	// 1
*		COLOR_BLUE		// 2
*	};
* 
* Объявление перечислений не требует памяти!
* Выделяется только когда переменная определена.
* 
* Можно: 
*	присваивать целочисленные значение
*	не присваивать значения
*	явно присваивать значения с плавающей точкой
*	присваивать значения предыдущих перечислителей
* 
* Могут быть:
*	отрицательными
*	не уникальными
* 
* @.'enum class' - перечисление с областью видимости
*	enum class Fruits { 
*		LEMON 
*	};
*	enum calss Colors { 
*		PINK 
*	};
*	Fruits fruit = Fruits::LEMON;
*	Colors color = Colors::PINK;
*
*	// ошибка компиляции, поскольку компилятор не знает, как сравнивать разные типы: Fruits и Colors
*	// без слова class был бы true, if (0 == 0)
*	if (fruit == color) { 
*		...
*	}

#endif // Перечисления

#ifdef typedef и type alias

* @.'typedef' - ключевое слово, позволяет создать псевдоним для любого типа данных
* Пример
*	typedef double time_t;
*	// следующие два стейтмента эквивалентны
*	double howMuch;
*	time_t howMuch;
* 
* 'Поддержка кода'
*	Если вы использовали тип short, но потом решили заменить на long:
*		Не придется шерстить кучу кода для замены short -> long, а просто заменить typedef
* 'Кроссплатформенность'
*	На некоторых платформах int занимает 2 байта, на других - 4 байта:
*		Вспомним про int8_t - это 8-битный signed int, и тд int16_t, int32_t.
* 'Упрощение сложного'
*	Можем увидеть следующее: 
* 
*	std::vector<std::pair<std::string, int>> pairlist;
* 
*	boolean hasAttribute(std::vector<std::pair<std::string, int>> pairlist) {
*		...
*	}
* 
*	Лучше:
*	typedef std::vector<std::pair<std::string, int>> pairlist_t
* 
*	pairlist_t pairlist;
* 
*	boolean hasAttribute(pairlist_t pairlist) {
*		...
*	}
* 
* Легко забыть 
*	typedef time_t double; // неправильно
*	typedef double time_t; // правильно
* TO DO (указ. на функции)
* 
* @.'type alias' - улучшенный синтаксис для typedef (C++11), который имитирует способ объявления переменных.
* Пример
* // typedef double time_t;
* using time_t = double;
* 
* !.'Правило:' Используйту type alias вместо typedef, если C++11

#endif // typedef и type alias

#ifdef struct

* @.'Структура' - пользовательский тип данных, группируют несколько отдельных переменных вместе.
* Пример
*	struct Employee
*	{
*		short id;
*		int age;
*		double salary;
*	};
* 
*	// john.id = 5
*	// john.age = 27
*	// john.salary = 0.0 (по умолчанию)
*	Employee john = { 5, 27 };
*	Employee john { 5, 27 };	// С++11
* 
* 'C++11'
*	1. Возможность установить значения по умолчанию
*		struct Triangle
*		{
*			double length = 2.0;
*			double width = 2.0;
*		};
* 
*	2. Возможность присваивать значения членам структур, используя список инициализаторов
*		Employee john;
*		john = { 5, 27, 45000.0 }
;
*	3. Uniform-инициализация
*		Employee john { 5, 27 };
* 
* 'С++14'
*	Совместимость инициализации нестатических членов структуры с списком иницализаторов или uniform-инициализаций.
*		struct Triangle
*		{
*			double length = 2.0; // нестатическая инициализация членов
*			double width = 2.0;
*		};
*		Triangle z = { 3.0, 3.0 }; // До С++11 включительно ошибка компиляции

#endif // struct

#ifdef Операторы управления потоком выполнения программ

* При запуске ЦП начинает выполнение кода с первой строки функции main();
* 
* @.'Порядок выполнения программы' (поток выполнения программы) - 
*		последовательность стейтментов, которые выполняет ЦП.
* 
* @.'Остановка' - сообщает программе немедленно прекратить свое выполнение.
*	#include <cstdlib> // для функции exit() 
*		которая возвращает целочисленный параметр в ОС в качестве выхода. 
* 
* @.'Прыжок' - сообщает компилятору перейти от одного стейтмента к другому.
*	ключевые слова goto, break, continue
*	вызовы функций
* 
* @.'Условное ветвление' - позволяет программу изменить свой порядок выполнения
* 
* @.'Цикл' - заставляет программу многократно выполнять определенное количество стейтментов.
*	while, do while, for, foreach (C++11)
* 
* @.'Исключения' - механизм обработки ошибок, возникающих в функции.
*	может выбросить исключение -> цп перейдет к ближнему блоку кода, который обрабатывает это исключение

#endif // Операторы управления потоком выполнения программ

#ifdef Генератор псевдослучайных чисел

* @.'Хороший ГПСЧ должен иметь ряд свойств:'
*	1. Генерировать каждое новое число с примерно одинаковой вероятностью
*	2. Метод, с помощью которого генерируется следующее число в последовательности,
*		не должен быть очевиден и предсказуем.
*	3. Должен иметь хорошее диапазонное распределение чисел.
*	4. Период повторений значений должен быть максимально большим
* 
* 'Самописный вариант'
* Пример
* unsigned int random() {
*	static unsigned int seed = 4541;
*	seed = (8253729 * seed + 2396403);
*	return seed % 32768;
* }
* 
* 
* 'srand() и rand()'
* @.'srand()' - устанавливает передаваемое значение в качестве стартового.
* @.'rand()' - генерирует случайное число в последовательности от 0 до RAND_MAX (константа в cstdlib)
* Недостаток: узкий диапазон (до 32767 - RAND_MAX)
* Пример
* #include <cstdlib>
* unsigned int random() {
*	return rand();
* }
* int main() {
*	srand(4541);
* }
* 
* 
* 'Добавляем time() в качестве стартового числа'
* Проблема:
*	При одном и том же стартовом числе, получаем одинаковую последовательность.
* Решение:
*	Использовать системные часы в качестве стартового числа
*	@.'time()' - возвращает в качестве времени общее количество секунд, прошедшее от полуночи 1 января 1970 г.
* Пример
* #include <cstdlib>
* #include <ctime>
* unsigned int random() {
*	return rand();
* }
* int main() {
*	srand(static_cast<unsigned int>(time(0)));
* }
* 
* 
* 'Случайные числа в заданном диапазоне'
* Пример 'Ravesli'
* unsigned int getRandomNumber(int min, int max) {
*	static const double fraction = 1.0 / (static_cast<double>(RAND_MAX) + 1.0);
*	return static_cast<int>(rand() * fraction * (max - min + 1) + min);
* }
* Пример самописный
* unsigned int getRandomNumber(int min, int max) {
*	return static_cast<int>(rand() % max + min);
* }
* 
* 
* @.'Вихрь Мерсенна' (C++11)
* Преимущество: широкий диапазон (32-битные целые числа unsigned и существует версия std::mt19937_64)
* Пример
* #include <random>
* unsigned int random(std::mt19937& seed) {
*	return seed() % 6 + 1;
* }
* 
* int main() {
*	std::random_device rd;
*	std::mt19937 seed(rd());
* }

#endif // Генератор псевдослучайных чисел

#ifdef Обработка некорректного пользовательского ввода

* @.'std::cin' 
*	Когда пользователь вводит данные в ответ на операцию извлечения, то эти данные помещаются 
*		в буфер std::cin
* @.'Буфер данных' - часть памяти, зарезервированная для временного хранения.
*	'>>' - оператор извлечения
*	При использовании оператора извлечения (>>), выполняется следующая процедура:
*		1. Если во входном буфере есть данные, то эти данные используются для извлечения
*		2. Если во входном буфере нет данных, то пользователю предлагается ввести данные.
*			* Когда пользователь нажимает Enter, символ новой строки '\n' помещается во входной буфер
*		3. Оператор >> извлекает данные из входного буфера в переменную, сколько позволяет размер самой переменной
*			* Игнорируя любые пробелы, '\t' и '\n'
*		4. Любые данные, которые не были извлечены, остаются во входном буфере.
* Пример
* #include <iostream>
* double getValue() {
*	while (true)
*	{
*		std::cout << "Enter a double value: ";
*		double a;
*		std::cin >> a;
*		
*		if (std::cin.fail()) {
*			std::cin.clear();
*			std::cin.ignore(32767, '\n');
*			std::cout << "Oops, that input is invalid. Please try again.\n";
*		}
*		else
*		{
*			std::cin.ignore(32767, '\n');
*			return a;
*		}
*	}
* }
* 
* @.'std::cin.fail()' - проверка на предыдущее значение, переполнение
* @.'std::cin.ignore(32767, '\n')' - удаляем значения предыдущего ввода из входного буфера, 
*	до 32767 символов или '\n' ('\n' также удаляем)

#endif // Обработка некорректного пользовательского ввода

#include "hi_lo.h"
#include <cstdlib>

int main() {
	srand(0);
	printStartGameMessage();
	do
	{
		play();
	} while (restartGame());
	printEndGameMessage();
}